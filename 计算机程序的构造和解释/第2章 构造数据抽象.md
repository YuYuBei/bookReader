简单的数值数据，对于解决许多问题而言，是不够的。
许多程序在设计时就是为了模拟复杂的对象，需要构造起一些计算对象，这些对象都是由一些部分组成的，以便去模拟真实世界里的那些具有若干侧面的对象。

 ## 将数据对象组合起来，形成复合数据的方式
 #### 为什么在程序设计语言里需要复合数据？
 为了提升在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。

### 设计一个系统，它完成有理数的算术
有理数：是一个整数a和一个非零整数b的比。有理数是整数和分数的集合。
```js
//a,b为两个有理数
function addRat(a,b){

}
```
分析：
 方法1､
 从基本数据出发，一个有理数可以看作两个整数，一个分子和一个分母。
 我们可以设计出一个程序，其中的每个有理数用两个整数表示，而其中addRat用两个过程实现。
 缺点：这样做会使我们必须明确地始终记住哪个分子与哪个分母相互对应。在需要执行大量有理数操作的系统里，这样的记录将会严重地扰乱我们的程序，而且这些麻烦又与我们真正想做的事情无关。

方法2､
如果将分子和分母“粘在一起”，形成一个对偶--复合数据对象--事情就会简单起来。程序中对有理数的操作可以将它们作为一个概念单位的方式进行。
复合数据的使用使我们进一步提高程序的模块性。
可以直接将有理数做为对象的方式操作。可以把处理有理数的那些程序，与有理数如何表示的细节隔离开。
这种将程序中处理数据对象的表示部分，与处理数据对象的使用部分相互隔离的技术，非常具有一般性，形成了一种称为数据抽象的设计方法学。
数据抽象技术可以使程序的设计、维护和修改更加的容易。

复合对象的使用将提高设计语言的表达能力。

形成“线性组合”ax+by，可以想到写一个过程，让它接受a,b,x和y作为参数并返回ax+by的值。如果以数值为参数，可以定义下面的函数：
```js
function linearCombination(a,b,x,y){
    return a*x+b*y;
}
```
如果我们关心的不仅仅是数，假定在写这个过程时，希望表述的是基于加和乘形成线性组合的思想，所针对的可以是有理数、复数、多项式或其他东西。我们可以把这个定义为下面这个函数：
```js
function linearCombination(a,b,x,y){
    return add(mul(a,x),mul(b,y));
}
```
其中add和mul不是基本的操作过程，而是更复杂的东西，它们能对通过参数a,b,x,和y送来的任何种类的数据执行适当的操作。
从linearCombination的角度看，a,b,x和y究竟是什么，并不重要，至于它们是怎样基于更基本的数据表示更没什么关系了。

为什么一种程序设计语言能够提供直接操作复合对象的能力是如此重要
因为如果没有这个能力，我们就没有办法让过程将其参数传递给其他过程，而不必知道这些参数的具体细节结构。

使用数据抽象在程序的不同部分之间建立起适当的数据屏障。
形成复合数据的关键在于，如何把一些数据对象组合起来，形成更复杂的数据对象。
怎样去构造出根本没有任何特定“数据”操作，只是由过程形成的复合数据。进一步模糊“过程”和“数据”之间的划分。

探索表示序列和树的一些常规技术。
在处理复合数据中的一个关键性思想是闭包的概念。
用于组合数据对象的方法，不但能组合基本的数据对象，同样可以用于复合的数据对象。

另一个思想是，复合数据对象能够成为以混合与匹配的方式组合程序模块的方便界面。
利用闭包概念的简单图形语言的方式，阐释有关的思想。

引用符号表达式，进一步扩大语言的表述能力。符号表达式的基本部分可以是任意的符号，不一定是数。

探索表示对象集合的各种不同方式，由此可以发现，一个给定的数学函数可以通过许多不同的计算过程计算一样，
对于一种给定的数据结构，也可以有许多方式将其表示为简单对象的组合，
而这种表示的选择，有可能对操作这些数据的计算过程的时间和空间需求造成重大的影响。
将在符号微分、集合的表示和信息编码的上下文中研究。

随后转去处理一个程序的不同部分可能采用不同的表示的数据的问题。实现通用型操作的需要，这种操作必须能处理许多不同的数据类型。
为了维持模块性，通用型操作的出现，将要求比只有简单数据抽象更强大的抽象屏障。
介绍数据导向的程序设计。这是一种允许我们孤立地设计每一种数据表示，而后添加的方式将它们组合进去。
将用已经学到的东西实现一个多项式符号算术的程序包，其中包括多项式的系数可以是整数、有理数、复数，甚至还可以是其它多项式。


## 2.1 数据抽象导引
可以这样造成一种抽象，它将一过程的使用方式，与该过程究竟如何通过更基本的过程实现的具体细节相互分离。针对复合数据的类似概念被称为数据抽象。
数据抽象是一种方法学，使我们可以将一个复合数据对象的使用，与该数据对象怎样由更基本的数据对象构造起来的细节隔离开。

数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在“抽象数据”上操作一样。
使用数据的方式是除了完成当前工作所必要的东西之外，不对所用数据做任何多余的假设。
一种“具体”数据表示的定义，也应该与程序中使用数据的方式无关。
两个部分之间的界面是一组过程，称为选择函数和构造函数，它们在具体表示之上实现抽象的数据。

### 2.1.1 实例：有理数的算术运算
假定希望做有理数上的算术，能做有理数的加减乘除运算，比较两个有理数是否相等。
开始：假定已经有一种从分子和分母构造有理数的方法。进一步，如果有了一个有理数，有一种方法取得它的分子和分母。
现在假定有关的构造函数和选择函数都可以作为过程使用：
- makeRat(n,d) 返回一个有理数，其分子是整数n，分母是整数d
- numer(x) 返回有理数x的分子
- denom(x) 返回有理数x的分母
这里使用一种称为按愿望思维的强有力的综合策略。现在思考如何去表示一个有理数，以及过程numer,denom和makeRat应如何实现。
如果我们真的有了这三个过程，那么就可以对有理数进行加减乘除和相等判断了。
实现过程如下：
```js
//有理数相加
function addRat(x,y){
    return makeRat(numer(x)*denom(y)+denom(x)*numer(y),denom(x)*denom(y));
}
//
function subRat(x,y){
    return makeRat(numer(x)*denom(y)-denom(x)*numer(y),denom(x)*denom(y));
}
//
function mulRat(x,y){
    return makeRat(numer(x)*numer(y),denom(x)*denom(y));
}
//
function divRat(x,y){
    return makeRat(numer(x)*denom(y),denom(x)*numer(y));
}
//
function equalRat(x,y){
    return numer(x)*denom(y)===denom(x)*numer(y);
}
```
这里已经有了定义在选择和构造过程numer、denom和makeRat基础之上的各种有理数运算，而这些基础还没有定义。
现在需要某种方式将一个分子和一个分母粘接起来，构成一个有理数。

序对 
具体层面上实现这一数据抽象，序对的复合结构，这种结构通过基本过程cons构造出来。过程cons取两个参数，返回一个包含这两个参数作为其成分的复合数据对象。
如果给了一个序对，可以用基本过程car和cdr，按如下方式提取出其中各个部分：
```js
```
一个序对也是一个数据对象，可以像基本数据对象一样给它一个名字且操作它。还可以用cons去构造那种其元素就是序对的序对，并且继续这样做下去。

序对可以用作构造任意种类的复杂数据结构的通用的基本构件。通过过程cons,car,cdr实现的这样一种最基本的复合数据，序对，也就是我们需要的所有东西。
从序对构造起来的数据对象称为表结构数据。

在js里只能用对象字面量来描述。
```js
var x={
    numer:1,
    denom:2
};
function car(x){
    return x.numer;
}
function cdr(x){
    return x.denom;
}
```
有理数的表示

序对完成这里的有理数系统提供了一种自然方式，可以将有理数简单表示为两个整数的序对。这样很容易做出makeRat,numer,denom的实现：
```js
function makeRat(x,y){
    return {
        numer:x,
        denom:y
    }
}
function numer(x){
    return car(x);
}
function denom(x){
    return cdr(x);
}
```
显示有理数的计算结果，将有理数打印为一个分子，在斜线符之后打印相应的分母。
```js
function printRat(x){
    console.log('\n');
    console.log(numer(x));
    console.log('/');
    console.log(denom(x));
}
var oneHalf=makeRat(1,2);
printRat(oneHalf);

var oneThird=makeRat(1,3);
printRat(oneThird);

printRat(addRat(oneHalf,oneThird));
printRat(mulRat(oneHalf,oneThird));
printRat(addRat(oneThird,oneThird));
```
有理数并没有将有理数约化到最简形式，通过修改makeRat可以很容易做到。要以使用最大公约数。

```js
function makeRat(x,y){
    var g=gcd(x,y);
    return {
        numer:x/g,
        denom:y/g
    };
}

printRat(addRat(oneThird,oneThird));
```

练习 2.1 定义makeRat的一个更好的版本，使之可以正确处理正数和负数。
当有理数是正时，makeRat应当将其规范化，使它的分子和分母都是正的。如果有理数为负时，那么应当只让分子为负。

```js
function makeRat(x,y){
    if(x<0 && y<0){
        x=-x;
        y=-y;
    }
    if(x*y<0 && x>0 ){
        x=-x;
        y=-y;
    }
    return {
        numer:x,
        denom:y
    }
}
```

### 2.1.2 抽象屏障
所有有理数的操作都是基于构造makeRat和选择函数numer,denom定义出来的。
数据抽象的基本思想是为每一类数据对象标识出一组操作，使得以这类数据对象的所有操作都可以基于它们表述，而且在操作这些数据对象时也只使用它们。
在每一层上，这种屏障都把使用数据抽象的程序（上面）与实现数据抽象的程序（下面）分开来。
使用有理数的程序将仅仅通过有理数包提供给“公众使用”的那些过程（addRat,subRat,mulRat,divRat和equalRat）去完成对有理数的各种操作；
这些过程转而又是完全基于构造函数和选择函数实现的；而这些又是基于序对实现的。
只要序对可以通过cons,car,cdr操作，有关序对如何实现的细节与有理数包的其余部分都完全没有关系。
从作用上看，每一层次中的过程构成了所定义的抽象屏障的界面，联系起系统中的不同层次。

这一简单思想的优点：
- 使程序很容易维护和修改。任意一种比较复杂的数据结构，都可以以多种不同方式用程序设计语言所提供的基本数据结构表示。
表示方式的选择会对操作它的程序产生影响，如果后来表示方式改变了，所有受影响的程序也都需要随之改变。
大型程序而言，这样的工作很耗时，而且代价极其昂贵，除非在设计时就已经将依赖于表示的成分限制到很少的一些程序模块上。

有理数约化到最简形式的工作，也完全可以不在构造的时候做，而是每次访问有理数中有关部分时做。这样就会导致另一套不同的构造函数和选择函数。

```js
function makeRat(x,y){
    return {
        numer:x,
        denom:y
    }
}
function numer(x){
    var g=gcd(car(x),cdr(x));
    return car(x)/g;
}
function denom(x){
    var g=gcd(car(x),cdr(x));
    return cdr(x)/g;
}
```
如果需要多次访问一个有理数的分子和分母，那么最好是在构造函数中计算gcd。如果不是这样，可以把gcd的计算推迟到访问时。
数据抽象方法使我们可以决定什么时间去决策，而不阻碍系统其他部分的工作进展。

练习 2.2
表示平面上线段的表示问题。一个线段用一对点表示，它们分别是线段的始点和终点。
定义makeSegment和选择函数startSegment,endSegment,它们基于点定义线段的表示。
一个点用数的序对表示，序对的两个成分分别表示点的x和y坐标。
进一步定义出构造函数makePoint和选择函数xPoint,yPoint，用它们定义出点的这种表示。最后，基于所定义的构造函数和选择函数，定义出函数midPointSegment,它以一个线段为参数，返回线段的中点。

```js
function makeSegment(p1,p2){
    return {
        startSegment:p1,
        endSegment:p2
    }
}
function startSegment(s){
    return s.startSegment;
}
function endSegment(s){
    return s.endSegment;
}

function makePoint(x,y){
    return {
        xPoint:x,
        yPoint:y
    }
}
function xPoint(p){
    return p.xPoint;
}
function yPoint(p){
    return p.yPoint;
}

function midPointSegment(s){
    var sp=startSegment(s);
    var ep=endSegment(s);
    return makePoint(Math.abs(xPoint(ep)-xPoint(sp))/2,Math.abs(yPoint(ep)-yPoint(sp))/2);
}
```

练习 2.3 实现一个平面矩形的表示。基于构造函数和选择函数定义几个过程，计算给定矩形的周长和面积等。

```js
//基于2.2
function makeRect(s1,s2){
    var s1StartPoint=startSegment(s1);
    var s1EndPoint=endSegment(s1);
    var s1StartPointX=xPoint(s1StartPoint);
    var s1StartPointY=yPoint(s1StartPoint);
    var s1EndPointX=xPoint(s1EndPoint);
    var s1EndPointY=yPoint(s1EndPoint);

    var s2StartPoint=startSegment(s2);
    var s2EndPoint=endSegment(s2);
    var s2StartPointX=xPoint(s2StartPoint);
    var s2StartPointY=yPoint(s2StartPoint);
    var s2EndPointX=xPoint(s2EndPoint);
    var s2EndPointY=yPoint(s2EndPoint);

    var w,h,x,y;
    if(s1StartPointX==s1EndPointX){
        h=Math.abs(s1EndPointY-s1StartPointY);
        w=Math.abs(s2EndPointX-s2StartPointX);
        x=s1StartPointX;
        y=s2StartPointY;
    }else{
        x=s2StartPointX;
        y=s1StartPointY;
        h=Math.abs(s2EndPointY-s2StartPointY);
        w=Math.abs(s1EndPointX-s1StartPointX);
    }
    var p=makePoint(x,y);
   
    return {
        point:p,
        width:w,
        height:h
    }
}
function perimeterRect(r){
    return wRect(r)*2+hRect(r)*2
}
function areaRect(r){
    return wRect(r)*hRect(r);
}
//另一种表示
function makeRect(p,w,h){
    return {
        point:p,
        width:w,
        height:h
    }
}
function wRect(r){
    return r.width;
}
function hRect(r){
    return r.height;
}
```

### 2.1.3 数据意味着什么
一般而言，我们总可以将数据定义为一组适当的选择函数和构造函数，以及使这些过程成为一套合法表示，它们就必须满足的一组特定条件。
如果用cons将两个对象粘接到一起，那么就可以借助于car和cdr提取出这两个对象。也就是说，这些操作满足条件是：对任何对象x和y，如果z是cons(x,y)那么
car z就是x，cdr z就是y。任何能满足上述条件的三个过程都可以成为实现序对的基础。

```js
function cons(x,y){
    return function(m){
        if(m==0)return x;
        if(m==1)return y;
        throw new Error('参数不对！');
    }
}
function car(x){
    return x(0);
}
function cdr(x){
    return x(1);
}
```

这里cons返回的值是一个过程，与之对应的car,cdr返回的我们需要序对提供的。序对的这一过程实现确实是合法的实现。
这一实例说明可以将过程作为对象去操作，因此就自动地为我们提供了一种表示复合数据的能力。
数据的过程性表示在程序设计中扮演一种核心角色。有关的程序设计风格通常称为消息传递。

练习 2.4

```js
function cons(x,y){
    return function(m){
        return m(x,y);
    }
}
function car(z){
    return z(function(p,q){
        return p;
    });
}
function cdr(z){
    return z(function(p,q){
        return q;
    })
}
```

练习 2.5

```js
/*
   构造函数，a,b产生2^a*3^b;
*/
function cons(a,b){
    return expt(2,a)*expt(3,b);
}
// a=2^a*3^b/2的次数
function car(z){
    if(z%2==0){
        return 1+car(z/2);
    }else{
        return 0;
    }
}
// b=2^a*3^b/3的次数
function cdr(z){
    if(z%3==0){
        return 1+cdr(z/3);
    }else{
        return 0;
    }
}
```
练习 2.6 在可以对过程做各种操作的语言里，可以将0和加一操作实现为

```js
function zero(){
    return function(f){
        return function(x){
            return x;
        }
    }
}

function add1(n){
    return function(f){
        return function(x){
            return f(n(f)(x));
        }
    }
}

//one = add1(zero);
var one=add1(function(f){
    return function(x){
        return x;
    }
})

var one=function(f){
    return function(x){
        return f(function(f){
            return function(x){
                return x;
            }
        }(f)(x));
    }
}
var one=function(f){
    return function(x){
        return f(x);
    }
}
//two=add1(one);
var two=add1(one);
var two=add1(function(f){
    return function(x){
        return f(x);
    }
});
var two=function(f){
    return function(x){
        return f(function(f){
            return function(x){
                return f(x);
            }
        }(f)(x));
    }
}
var two=function(f){
    return function(x){
        return f(f(x));
    }
}

//实现加法,累积两个参数的f的调用次数
function add(a1,a2){
    return function(f){
        return function(x){
               return a1(f)(a2(f)(x)))
        }
    }
    
}
//完成three=one+two
var three=add(two,one);
var three=add(function(f){
    return function(x){
        return f(f(x));
    }
},function(f){
    return function(x){
        return f(x);
    }
});
var three=function(f){
    return function(x){
           return function(f){
                return function(x){
                    return f(f(x));
                }
            }(f)(function(f){
                return function(x){
                    return f(x);
                }
            }(f)(x));
    }
}

var three=function(f){
    return function(x){
        return function(x){
           return function(f){
                return function(x){
                    return f(f(x));
                }
            }(f)(f(x));
        }
     }
}
var three=function(f){
    return function(x){
        return f(f(f(x)));
    }
}
```

### 2.1.4 扩展练习：区间算术
设计一个求解工程问题的系统。这个系统可以能够去操作不准确的量，这种量具有已知的精度，在对这种近似值进行计算时，得到的结果也应该是已知精度的数值。
电子工程师，使用系统计算一些电子量。有时必须使用下面公式，从两个电阻R1和R2计算出并联等价电阻Rp的值：
Rp=1/(1/R1+1/R2)
所知的电阻值通常是由电阻生产厂商给出的误差保证的值。
如：
6.8欧姆误差10%的电阻，其电阻值的范围是6.8-0.68=6.12到6.8+0.68=7.48之间。
如果把这个电组和一个4.7欧姆误差为5%的电阻并联，这一组合的电阻值在2.58欧姆到2.97欧姆之间。
实现一套“区间算术”，即作为可用于组合的“区间”的一组算术运算。两个区间的加、减、乘、除的结果仍是一个区间，表示的是计算结果的范围。

称为区间的抽象对象，这个对象的两个端点，一个是下界和一个上界。
给一个区间的两个端点，就可以用数据结构构造函数makeInterval构造出相应的区间来。



```js
//区间加法
function addInterval(x,y){
    return makeInterval(lowerBound(x)+lowerBound(y),upperBound(x)+upperBound(y));
}

//区间乘法
function mulInterval(x,y){
    var p1=lowerBound(x)*lowerBound(y);
    var p2=lowerBound(x)*upperBound(y);
    var p3=upperBound(x)*lowerBound(y);
    var p4=upperBound(x)*upperBound(y);
    return makeInterval(min(p1,p2,p3,p4),max(p1,p2,p3,p4));
}

//区间除法
function divInterval(x,y){
    return mulInterval(x,makeInterval(1/upperBound(y),1/lowerBound(y)));
}

```

练习 2.7

```js
function makeInterval(a,b){
    return function(m){
        if(m==0)return a;
        if(m==1)return b;
        throw new Error('不合法的参数！');
    }
} 
function lowerBound(x){
    return x(0);
}
function upperBound(x){
    return x(1);
}
```

练习 2.8

```js
//区间差
function subInterval(x,y){
    return makeInterval(max(lowerBound(x),lowerBound(y)),min(upperBound(x),upperBound(y)));
}
```

练习 2.9

```js
//区间宽度
function halfInterval(x){
    return (upperBound(x)-lowerBound(x))/2
}

/*
证明 halfInterval(addInterval(x,y)) == addInterval(halfInterval(x),halfInterval(y))
展开：halfInterval(addInterval(x,y))
halfInterval(makeInterval(lowerBound(x)+lowerBound(y),upperBound(x)+upperBound(y)))
upperBound(makeInterval(lowerBound(x)+lowerBound(y),upperBound(x)+upperBound(y)))-lowerBound(makeInterval(lowerBound(x)+lowerBound(y),upperBound(x)+upperBound(y)))/2
(upperBound(x)+upperBound(y)-lowerBound(x)-lowerBound(y))/2
(upperBound(x)-lowerBound(x))/2+(upperBound(y)-lowerBound(y))/2
与
addInterval(halfInterval(x),halfInterval(y))的展开式相同
同理可证减法。
由于乘除，无法根据参数区间的上下界去单一确定一个新的区间，所以其宽度也无法通过两个区间的宽度获得。
*/
```
 练习 2.10

 ```js
 function checkInterval(x){
     if(lowerBound(x)<0 && upperBound(x)>0){
         return false;
    }
     return true;
 }
```

练习 2.11

//todo:后面继续解题，先进行书的下一节。


## 2.2 层次性数据和闭包性质
序对，提供了一种用于构造复合数据的基本能力。
可以建立元素本身也是序对的序对，这是表结构得以作为一种表示工具的根本基础。这种能力称为cons的闭包性质。
某种组合数据对象的操作满足闭包性质，通过它组合起来数据对象得到的结果本身还可以通过同样的操作再进行组合。
闭包性质是任何一种组合功能的威力的关键要素。
它使我们可以建立层次性质的结构，这种结构由一些部分构成，而其中的各个部分又是由它们的部分构成，并且可以如此继续下去。

用序对来表示序列和树。

### 2.2.1 序列的表示
利用序对可以构造出序列--一批数据对象的一种有序汇集。

```lisp
(cons 1 
    (cons 2
        (cons 3 
            (cons 4 nil))))
```
通过嵌套的cons形成的一个序对的序列称为一个表。Scheme为方便表的构造，提供了一个基本操作list，上面的序列可以用(list 1 2 3 4)产生.
(list <a1> <a2> <a3> ... <an>) 
等价于
(cons <a1> (cons <a2> (cons ... (cons <an> nil) ...)))


```lisp
(define one-through-four (list 1 2 3 4))
one-through-four
```

可以通过car获取第一项，cdr获取除去第一项之后剩下的所有项形成的子表。
nil的值表示序列对的链结束，它可以当作一个不包含任何元素的序列，空表。

```js
//这里使用js，只是为了更好的理解书本中的意思
function list(){
    function listIter(items,count,i){
        if(i>count){
            return 'nil';
        }else{
            return cons(items[i],listIter(items,count,i+1));
        }
    }
    return listIter(arguments,arguments.length-1,0);
}
```


表操作
利用序对将元素的序列表示为表之后，可以使用常规的程序设计技术，通过顺序“向下cdr”表的方式完成对表的各种操作。

下面过程list-ref的实际参数是一个表和一个数n，它返回这个表中的第n个项。令表元素的编号从0开始。
计算list-ref的方法如下：
- 对n=0,list-ref应返回表的car
- 否则，list-ref返回表的cdr的第(n-1)个项

```lisp
(define (list-ref items n)
    (if(= n 0)
        (car items)
        (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))
(list-ref squares 3)
16


```

```js
function listRef(items,n){
    if(n==0){
        return car(items);
    }else{
        return listRef(cdr(items),n-1);
    }
}
```
// scheme包含一个基本操作null?用于检查参数是不是空表。返回表中项数的length

```
(define (length items)
（if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5))
(length odds)
3
```

```js
function length(items){
    if(isNull(items)){
        return 0;
    }else{
        return 1+length(cdr(items));
    }
}
```


- 任意一个表的length就是这个表的cdr的length加一
顺序地这样应用，直至达到了基础情况
- 空表的length是0
迭代计算方式来计算length

```
(define (length items)
    (define (length-iter a count)
        (if (null? a)
            count
            (length-iter (cdr a ) (+ 1 count))))
    (length-iter items 0))
```

```js
function length(items){
    function lengthIter(a,count){
        if(isNull(a)){
            return count;
        }else{
            return lengthIter(cddr(a),count+1);
        }
    }
    return lengthIter(items,0);
}
```

另一种程序设计技术，是在向下cdr一个表的过程中“向上cons”出一个结果表
过程append，它以两个表为参数，用它们的元素组合成一个新表：
```
(append squares odds)
(1 4 9 16 25 1 3 5)
(append odds squares)
(1 3 5 1 4 9 16 25)
```
append，要得到表list1和list2的append，按如下的方式做：
- 如果list1是空表，结果就是list2
- 否则应先做出list1的cdr和list2的append，而后将list1的car通过cons加到结果的前面
```
(define (append list1 list2))

```
### 对表的映射
一个特别有用的操作是将某种变换应用于一个表的所有元素，得到所有结果构成的表。
过程将一个表里的所有元素按给定因子做一次缩放：

```
(define (scale-list items factor)
    (if (null? items)
        nil
        (cons (* (car items) factor)
                (scale-list (cdr items) factor))))
(scale-list (list 1 2 3 4 5 6) 10)
(10 20 30 40 50 60)
```
可以将其中的公共模式表述为一个高阶过程，这一高阶过程称为map，它有一个过程参数和一个表参数，返回将这一过程应用于表中各个元素得到的结果形成的表。

```
(define (map proc items)
    (if (null? items)
        nil
        (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11 19))
(10 2.5 11 19)
(define (scale-list items factor)
    (map (lambda (x) (* x factor)) items))
```
map 建立起来处理表的高层抽象
通过使用map来定义scale-list抑制了细节层面上的情况，强调的是从元素表到结果表的一个缩放变换。
两种定义的方式的差异：
不在于计算机会执行不同的计算过程，而在于我们对这同一个过程的不同思考方式
从作用上看，map帮我们建立起了一层抽象屏障，将实现表变换的过程的实现，与如何提取表中元素以及组合结果的细节隔离开。
这种抽象提供了使我们有可能在保持从序列到序列的变换操作框架的同时，改变序列实现的低层细节。

练习 2.21

```
(define (squares-list items)
    (if (null? items)
        nil
        (cons (car items)  
                 (squares-list (cdr items)))))

(define (squares-list items)
    (map (lambda (x) (* x x)) items))
```

练习 2.22

//todo:代码之后再添加，先看书

### 2.2.2 层次性结构
将表做为序列的表示方式，可以推广到表示那些元素也是序列的序列。
((1 2) 3 4)
(cons (list 1 2) (list 3 4))

认识这种元素自身也是序列的序列的另一种方式，是把它们看作树
序列中的元素就是树的分支，那些本身也是序列的元素就形成了树中的子树

递归是处理树结构的一种很自然的工具。可以将对于树的操作归结为对它们的分支的操作，再将这种操作归结为分支的分支的操作。
直至达到了树的叶子。

//todo:树结构相关操作
count-leaves

对树的映射
map 是处理序列的一种强有力的抽象，map与递归的结合也是处理树的一种强有力抽象。
scale-tree

### 2.2.3序列作为一种约定的界面
强调数据抽象对复合数据的工作中起作用，借助这种思想，
可以设计出不会被数据表示的细节纠缠的程序，使程序能够保持很好的弹性，得以应用不同的具体表示上。

介绍与数据结构相关的另一种强有力的设计原理--使用约定的界面。
可以通过实现为高阶过程的程序抽象，抓住处理数值数据的一般程序模式。
要在复合数据上工作做出类似的操作，对数据结构的方式有很强的依赖性。
以一棵树为参数，计算出那些值为奇数的叶子的平方和：
//sum-odd-squares

构造出的是所有偶数的斐波契数fib(k)的一个表，其中的k小于等于某个给定整数n：
//even-fibs

上面两个过程在结构上差异非常大，但是对于两个计算的抽象描述却有极大的相似处。
第一个过程：
- 枚举出一棵树的树叶
- 过滤它们，选出其中的奇数
- 对选出的每一个数求平方
- 用+累积起得到的结果，从0开始

第二个过程：
- 枚举从0到n整数
- 对每个整数计算相应的斐波那契数
- 过滤它们，选出其中的偶数
- 用cons累积得到的结果，从空表开始

//信息处理工作
从一个枚举器开始，流过一个过滤器删除不满足条件的，通过映射对元素进行转换，累积器把所有元素重新组织起来。

这样的工作流，被分散到程序的各个部分，并且各部分也混在一起。
能够重新组织程序，使处理过程按照工作流进行，将会大大提高结果代码的清晰度。

序列操作
要更好组织程序使之能够清晰反应处理过程的结构，最关键的将注意力集中在处理过程中从一个步骤到下一个步骤的“信号”。
用一些表来表示这些信号，可以利用表操作实现每一个步骤的处理。
//todo:这里有个例子代码，后面补上

将程序表示为一些针对序列的操作，能帮助我们得到模块化的程序设计。得到由一些比较独立的片段的组合构成的设计。
通过提供一个标准部件的库，并使这些部件都有着一些能以各种灵活方式相互连接的约定界面，将能进一步推动人们去估模块化的设计。

在工程设计中，模块化结构是控制复杂性的一种威力强大的策略。
在真实的信号处理应用中，通常总是从标准化的过滤器和变换装置族中选出一些东西，通过级联的方式构造出各种系统。
序列操作也形成可以混合和匹配使用的标准的程序元素库。

用表实现的序列被作为一种方便的界面，可以利用这种界面去组合起各种处理模块。
如果以序列作为所用的统一表示结构，我们就能将程序对于数据结构的依赖性局限到不多的几个序列操作上。
通过修改这些操作，就可以在序列的不同表示之间转换，并保持程序的整个设计不变。

嵌套映射

可以扩充序列范型，将许多通常用嵌套循环表述的计算也包含进来。
问题：给定了自然数n，找了所有不同的有序对i和j,其中1<=j<i<=n，使得i+j是素数。
例如：假定n是6,满足条件的序对就是：
i       |  2  3  4  4  5  6  6
j       |  1  2  1   3  2  1  5
---------------------------
i+j    |  3  5  5  7  7  7  11

完成这一计算的一种很自然的组织方式：
- 首先生成出所有小于等于n的正自然数的有序对
- 而后通过过滤，得到那些和为素数的有序对
- 最后对每个通过了过滤的序对(i,j),产生出一个三元组(i,j,i+j)

生成有序对的序列的一种方式：
对每个整数i<=n，枚举出所有的整数j<i，并对每一对i和j生成序对(i,j)。

序列操作的方式说，要对序列(enumerate-interval 1 n)做一映射。
对于这个序列中里的每个i，都要对序列(enumerate-interval 1 (- i 1))做映射。
对于后一个序列中的每个j，我们要生成序对(list i j)。
这样就对每个i得到一个序对的序列。
将针对所有i的序列组合到一起，就产生出所需的序对序列。

//todo:这里代码需后期补上

### 2.2.4 实例：一个图形语言
介绍一种用于画图形的简单语言，以展示数据抽象和闭包的威力，其中也以一种很本质的方式使用了高阶过程。

图形语言

描述一种语言时，应该将注意力集中到语言的基本原语、它的组合手段以及它的抽象手段。

语言中只有一种元素，称为画家。
一个画家将画出一个图像，这种图像可以变形或者改变大小，以便能正好放到某个指定的平等四边形框架里。

举例：有一个称为wave的基本画家，它能做出折线画，而所做出图画的实际形状依赖于具体的框架。

有些画家可以图照片，称为rogers的基本画家。

为了组合起有关的图像，用一些可以给定画家构造出新画家的操作。
例如：
操作beside从两个画家出发，产生一个复合画家，它将第一个画家的图像画在框架中左边的一半里，将第二个画家的图像画在框架的右边一半里。
below从两个画家出发产生一个组合型画家，将第一个画家的图像画在第二个画家的图像之下。

有些操作将一个画家转换为另一个新画家。
例如：
flip-vert从一个画家出发，产生一个将该画家所画图像上下颠倒画出的画家
flip-horiz产生的画家将原画家的图像左右反转后画出。

在按这种方法构造复杂的图像时，利用了一个事实：
画家有关的语言的组合方式下是封闭的：
两个画家的beside或者below还是画家，还可以用它们作为元素去构造更复杂的画家。
就像用cons构造起各种表结构一样，所用的数据在组合方式下的闭包性质非常重要，这使我们能用不多几个操作构造出各种复杂的结构。

希望能抽象出典型的画家组合模式，以便将这种组合操作实现为一些过程。
这意味着我们并不需要这种图形语言里包含任何特殊的抽象机制，组合的方式是采用普通的过程。
对于画家，自动有了能够做原来可以对过程做的所有事情。


//todo 一些代码

可以定义一些递归操作

```js
function rightSplit(painter,n){
    if(n==0){
        return painter;
    }else{
        var smaller=rightSplit(painter,n-1);
        return beside(painter,below(smaller,smaller))
    }
}

function cornerSplit(painter,n){
    if(n==0){
        return painter;
    }else{
        var up=upSplit(painter,n-1);
        var right=rightSplit(painter,n-1);
        var topLeft=beside(up,up);
        var bottomRight=below(right,right);
        var corner=cornerSplit(painter,n-1);
        return beside(below(painter,topLeft),below(bottomRight,corner));
    }
}

function squaresLimit(painter,n){
    var quarter=cornerSplit(painter,n)
    var half=beside(flipHoriz(quarter),quarter);
    return below(flipVert(half),half);
}
```
练习 2.44
//upSplit代码

高阶操作
除了组合画家的抽象模式外，可以在高阶上工作，抽象出画家的各种组合操作的模式。
可以把画家操作看成是操控和描写这些元素的组合方法的元素--写出一些过程，它们以画家操作作为参数，创建出各种新的画家操作。

flipped-pairs、square-limit两者都将一个画家的四个拷贝安排在一个正方形的模式中，它们之间的差异仅仅在这些拷贝的旋转角度。

抽象出这种画家组合模式的一种方式是定义，基于四个单参数的画家操作，产生出一个画家操作，这一操作里将用这四个操作去变换一个给定的画家，
并将得到的结果放入一个正方形里。
tl、tr、bl、br，分别是应用于左上角，右上角，左下角，右下角的四个拷贝的变换：

```js
function squareOfFour(tl,tr,bl,br){
    return function(painter){
        var top=beside(tl(painter),tr(painter));
        var bottom=beside(bl(painter),br(painter));
        return below(bottom,top);
    }
}
function flipperPairs(painter){
    var combine4=squareOfFour(identity,flipVert,identity,flipVert);
    return combine4(painter);
}
function squaresLimit(painter,n){
    var combine4=squareOfFour(flipHoriz,identity,rotate180,flipVert);
    return combine4(corner(painter,n));
}
```
练习 2.45
//split代码
function rightSplit(painter,n){
    var com=split(beside,below);
    if(n==0)return painter;
    return com(painter,rightSplit(painter,n-1))
}

框架（图像的外框）
一个框架可以用三个向量描述：
一个基准向量和两个角向量。
基准向量：描述的是框架基准点相对于平面上某个绝对基准点的偏移量
角向量：描述了框架的角相对于框架基准点的偏移量

如果两个角向量正交，这个框架就是一个矩形。否则它就是一个一般的平行四边形。

根据数据对象的抽象原理，不用说清楚框架的具体表示方式，而只需要说明，存在着一个构造函数makeFrame，它能从三个向量出发做出一个框架。
与之对应的选择函数是originFrame,edge1Frame,edge2Frame。

用单位正方形(0<=x,y<=1)里的坐标去描述图像。
对于每个框架，我们要为它关联一个框架坐标映射，借助它完成有关图像的位移和伸缩，使之能够适配于这个框架。
这一映射的功能就是把单位正方形变换到相应框架，所采用的方法就是将向量v=(x,y)映射到下面的向量和：
orign(frame)+x*edge1(frame)+y*edge2(frame)

例如：
点(0,0)将被映射到给定框架的原点，(1,1)被映射到与原点对角的那个点，而(0.5,0.5)被映射到给定框架的中心点。
可以通过下面过程建立起框架的坐标映射：

```js
function frameCoordMap(frame){
    return function(v){
        return addVect(originFrame(frame),addVect(scaleVect(xcorVect(v),edge1Frame(frame)),scaleVect(ycorVect(v),edge2Frame(frame))));
    }
}

frameCoordMap(aFrame)(makeVect(0,0));
```

练习 2.46 
makeVect
xcorVect
ycorVect

addVect
subVect
scaleVect

练习 2.47

画家
一个画家被表示为一个过程，以框架作为实际参数，可以通过适当的位移和伸缩，画出一幅与这个框架匹配的图像。
如果p是一个画家而f是一个框架，通过以f作为实际参数调用p，就能产生出f中p的图像。

基本画家的实现细节依赖于特定图形系统的各种特性和被画图像的种类。
假定现在有一个过程drawLine，它能在屏幕上两个给定点之间画出一条直线，那么我们就可以利用它创建一个画折线图的画家。

```js
function segmentsPainter(segmentList){
    return function(frame){
        for(var i=0,len=segmentList.length;i<len;i++){
            var segment=segmentsPainter[i];
            var p1=frameCoordMap(frame)(startSegment(segment));
            var p2=frameCoordMap(frame)(endSegment(segment));
            drawLine(p1,p2);
        }
    }
}
```

将画家表示为过程，在这一图形语言中坚立起一道强有力的抽象屏障。
使我们可以创建和混用基于各种图形能力的各种类型的基本画家。
任何过程只要能取一个框架作为参数，画出某些可以伸缩后适合这个框架的东西，它就可以作为一个画家。

练习 2.48

练习 2.49

画家的变换和组合
各种对画家的操作的功能就是创建另一个画家，这里涉及到原来的画家，以及根据参数框架派生出的某些框架。
例如：
flipVert在反转画家时完全不必知道它们究竟如何工作，只需要知道怎样将一个框架上下颠倒就好了。产生出的画家使用的仍是原画家，只不过它在一个颠倒的框架里工作。

画家的操作都基于transformPainter，它以一个画家以及有关怎样变换框架和生成画家的信息作为参数。
对一个框架调用这样的变换去产生画家，实际完成的是对这个框架的一个变换，并基于变换后的框架去调用原来的画家。
transformPainter的参数是一些点（用向量表示），它们描述了新框架的各个角。
用于做框架变换时，
第一个参数描述的是新框架的原点
别外两个点描述的是新框架的两个边向量的终点。
这样，位于单位正方形里的参数描述的就是一个包含在原框架里面的框架。

```js
function transformPainter(painter,origin,corner1,corner2){
    return function(frame){
        var m=frameCoordMap(frame);
        var newOrigin=m(origin);
        return painter(makeFrame(newOrigin,subVect(m(corner1),newOrigin),subVect(m(corner2),newOrigin)));
    }
}
//垂直反转
function flipVert(painter){
    return transformPainter(painter,makeVect(0,1),makeVect(1,1),makeVect(0,0));
}
//
function shrinkToUpperRight(painter){
    return transformPainter(painter,makeVect(0.5,0.5),makeVect(1,0.5),makeVect(0.5,1));
}
//
function rotate90(painter){
    return transformPainter(painter,makeVect(1,0),makeVect(1,1),makeVect(0,0))
}
//
function squashInwards(painter){
    return transformPainter(painter,makeVect(0.35,0.35),makeVect(0.65,0.35),makeVect(0.35,0.65));
}

```

画家的数据抽象，特别是将画家用过程表示，怎样使beside的实现变得如此简单。
这里的beside完全不必了解作为其成分的各个画家的任何东西，它只需要知道这些画家能够在指定框架里画出一些东西就够了。


强健设计的语言层次
前面介绍的有关过程和数据抽象的关键思想，得到演示。

基本数据抽象和画家都用过程表示实现，使语言能以一种统一方式去处理各种本质上完全不同的画图能力。
实现组合的方法也满足闭包性质，使我们可以轻易构造起各种复杂的设计。
用于做过程抽象的所有工具，都可用作组合画家抽象手段。

对程序设计的另一个关键概念，分层设计。一个复杂的系统应该通过一系列的层次构造出来，为了描述这些层次，需要使用一系列的语言。
构造各个层次的方式，就是设法组合起来人作为这一层次中部件的各种基本元素，而这样构造出来的部件又可以作为另一个层次里的基本元素。
在分层设计中，每个层次上所用的语言都提供了一些基本元素、组合手段，还有对层次中的适当细节做抽象的手段。

在复杂系统的工程中广泛使用这种分层设计方法。
例如：在计算机工程里，电阻和晶体管被组合起来（用模拟电路的语言），产生了一些部件，例如与门、或门等等。
这些门电路又被作为数字电路设计的语言中的基本元素。
将这类部件组合起来，构成了处理器、总线和存储系统又通过它们的组合构造出各种计算机，此时采用的是适合于计算机体系结构的语言。

分层设计有助于使程序更加强健，使我们在给定规范发生一些小变时，只需要修改少量的代码。

分层结构中的每个层次都为表述系统的特征提供一套独特词汇，以及一套修改这一系统的方式。

练习 2.52


## 2.3 符号数据
使用过的所有复合数据，都是从数值出发构造起来的。
扩充语言的表述能力，引进任意符号作为数据的功能。

### 2.3.1 引号
如果能构造出采用符号的复合数据。

(a b c d)
(23 45 17)

这些包含着符号的表看起来就像我我们语言里的表达式

(* (+ 23 45) (+ x 9))
(define (fact n) (if (= n 1) 1 (* n (fact (- n 1)))))

为了能操作这些符号，语言里就需要一种新元素：为数据对象加引号的能力。
如果我们希望构造(a b)，不能用(list a b)完成，因为这一表达式将要构造出的是a和b的值的表，而不是这两个符号本身的表。

将表和符号标记为应该人作为数据对象看待，而不是作为应该求值的表达式。这里可以使用引号。

//todo 这里欠了很多代码
练习 2.53
练习 2.54
练习 2.55

### 实例：符号求导
进一步阐述数据抽象的思想
设计一个执行代数表达式的符号求导的过程。

希望该过程以一个代数表达式和一个变量作为参数，返回这个表达式相对于该变量的导数。
如，如果送给这个过程的参数是ax^2+bx+c和x，它应该返回2ax+b。
符号求导数对于Lisp有着特殊的意义，它正是推动人们去为符号操作开发计算机语言的重要实例之一。
人们为符号数学工作开发强有力系统的研究领域的开端。

为开发出一个符号计算程序，像开发有理数系统那样，采用同样的数据抽象策略。

首先，定义一个求导算法，令它在一些抽象对象上操作。例如“和”、“乘积”和“变量”，并不考虑这些对象实际上如何表示，后面才关心具体表示的问题。

对抽象数据的求导程序

先考虑一个简单的符号求导程序，它处理的表达式都是由对于两个参数的加和乘运算构造起来的。

dc/dx=0
dx/dx=1
d(u+v)/dx=du/dx+dv/dx
d(uv)/dx=u(dv/dx)+v(du/dx)

最后两条规则具有递归的性质。
要想得到一个和式的导数，
首先，要找出其中各个项的导数，而后将它们相加。
这里的每个项又可能是需要进一步分解的表达式。
通过这种分解，得到越来越小的片段，最终将产生出常量或者变量，它们的导数就是0或1;

有一种表示代数表达式的方式，一定能判断出某个表达式是否是一个和式、乘式、常量或变量，提取出表达式里的各个部分。

对于一个和式，希望取得其被加项和加项。
能从几个部分出发构造出整个表达式。

假定实现已经有了一些过程，它们实现下面的构造函数、选择函数和谓词：

```
(variable? e)                  //e是变量吗？
(same-variable? v1 v2)   //v1和v2是同一个变量吗？
(sum? e)                      //e是和式吗？
(addend e)                   //e的被加数
(augend e)                   //e的加数
(make-sum a1 a2)         //构造起a1和a2的和式

(product? p)                 //e是乘式吗？
(multiplier e)                 //e的被乘数
(multiplicand e)             //e的乘数
(make-product m1 m2)  //构造起m1和m2的乘式
```

利用这些过程，以及判断表达式是否数值的基本过程number?，就可以将各种求导规则表达出来

```
(define (deriv exp var)
   (cond ((numer? exp) 0)
            ((variable? exp)
             (if (same-variable? exp var) 1 0))
            ((sum? exp)
             (make-sum (deriv (addend exp) var)
                             (deriv (augend exp) var)))
            ((product? exp)
             (make-sum 
                 (make-product (multiplier exp)
                                       (deriv (multiplicand exp) var))
                 (make-product (deriv (multiplier exp) var)
                                       (multiplicand exp))))
            (else
              (error "unknow expression type -- DERIV " exp))))
```

deriv里包含了一个完整的求导算法。
它是基于抽象数据表述的，因此，无论如何选择代数表达式的具体表示，只要设计了一组正确的选择函数和构造函数，
这个过程都可以工作。表示的问题是下面必须考虑的问题。

代数表达式的表示
我们可以设想出用表结构表示代数表达式的方法。
例如，可以利用符号的表直接反应代数的记法形式，将表达式ax+b表示为表（a * x + b）。
一种更直接了当的选择，是采用lisp里面表示组合式的那种带括号的前缀形式。
将ax+b表示为（+ （* a x）b）。

有关求导的问题就是：
- 变量就是符号，它们可以用基本谓词symbol?判断：
(define (variable? x) (symbol? x))

- 两个变量相同就是表示它们的符号相互eq?:
(define (same-variable? v1 v2) 
          (and (variable? v1) (variable? v2) (eq? v1 v2)))

- 和式与乘式都构造为表：
(define (make-sum a1 a2) (list + a1 a2))
(define (make-product m1 m2) (list * m1 m2))

- 和式就是第一个元素为符号+的表
(define (sum? x) 
        (and (pair? x) (eq? (car x) '+)))

- 被加数是表示和式的表里的第二个元素
(define (addend s) (cadr s))

- 加数是表示和式的表里的第三个元素
(define (addend s) (caddr s))

- 乘式就是第一个元素为符号*的表：
(define (product? x) 
        (and (pair? x) (eq? (car x) '*)))

- 被乘数是表示乘式的表里的第二个元素
(define (multiplier p) (cadr p))

- 乘数是表示乘式的表里的第三个元素
(define (multiplicand p) (caddr p))

只需要把这些过程与deriv放在一起。

(deriv '(+ x 3) 'x)
(+ 1 0)

(deriv '(* x y) 'x)
(+ (* x 0) (* 1 y))





