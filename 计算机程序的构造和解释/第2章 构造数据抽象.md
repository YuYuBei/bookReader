简单的数值数据，对于解决许多问题而言，是不够的。
许多程序在设计时就是为了模拟复杂的对象，需要构造起一些计算对象，这些对象都是由一些部分组成的，以便去模拟真实世界里的那些具有若干侧面的对象。

 ### 将数据对象组合起来，形成复合数据的方式
 #### 为什么在程序设计语言里需要复合数据？
 为了提升在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。

### 设计一个系统，它完成有理数的算术
有理数：是一个整数a和一个非零整数b的比。有理数是整数和分数的集合。
```js
//a,b为两个有理数
function addRat(a,b){

}
```
分析：
 方法1､
 从基本数据出发，一个有理数可以看作两个整数，一个分子和一个分母。
 我们可以设计出一个程序，其中的每个有理数用两个整数表示，而其中addRat用两个过程实现。
 缺点：这样做会使我们必须明确地始终记住哪个分子与哪个分母相互对应。在需要执行大量有理数操作的系统里，这样的记录将会严重地扰乱我们的程序，而且这些麻烦又与我们真正想做的事情无关。

方法2､
如果将分子和分母“粘在一起”，形成一个对偶--复合数据对象--事情就会简单起来。程序中对有理数的操作可以将它们作为一个概念单位的方式进行。
复合数据的使用使我们进一步提高程序的模块性。
可以直接将有理数做为对象的方式操作。可以把处理有理数的那些程序，与有理数如何表示的细节隔离开。
这种将程序中处理数据对象的表示部分，与处理数据对象的使用部分相互隔离的技术，非常具有一般性，形成了一种称为数据抽象的设计方法学。
数据抽象技术可以使程序的设计、维护和修改更加的容易。

复合对象的使用将提高设计语言的表达能力。

形成“线性组合”ax+by，可以想到写一个过程，让它接受a,b,x和y作为参数并返回ax+by的值。如果以数值为参数，可以定义下面的函数：
```js
function linearCombination(a,b,x,y){
    return a*x+b*y;
}
```
如果我们关心的不仅仅是数，假定在写这个过程时，希望表述的是基于加和乘形成线性组合的思想，所针对的可以是有理数、复数、多项式或其他东西。我们可以把这个定义为下面这个函数：
```js
function linearCombination(a,b,x,y){
    return add(mul(a,x),mul(b,y));
}
```
其中add和mul不是基本的操作过程，而是更复杂的东西，它们能对通过参数a,b,x,和y送来的任何种类的数据执行适当的操作。
从linearCombination的角度看，a,b,x和y究竟是什么，并不重要，至于它们是怎样基于更基本的数据表示更没什么关系了。

为什么一种程序设计语言能够提供直接操作复合对象的能力是如此重要
因为如果没有这个能力，我们就没有办法让过程将其参数传递给其他过程，而不必知道这些参数的具体细节结构。

使用数据抽象在程序的不同部分之间建立起适当的数据屏障。
形成复合数据的关键在于，如何把一些数据对象组合起来，形成更复杂的数据对象。
怎样去构造出根本没有任何特定“数据”操作，只是由过程形成的复合数据。进一步模糊“过程”和“数据”之间的划分。

探索表示序列和树的一些常规技术。
在处理复合数据中的一个关键性思想是闭包的概念。
用于组合数据对象的方法，不但能组合基本的数据对象，同样可以用于复合的数据对象。

另一个思想是，复合数据对象能够成为以混合与匹配的方式组合程序模块的方便界面。
利用闭包概念的简单图形语言的方式，阐释有关的思想。

引用符号表达式，进一步扩大语言的表述能力。符号表达式的基本部分可以是任意的符号，不一定是数。

探索表示对象集合的各种不同方式，由此可以发现，一个给定的数学函数可以通过许多不同的计算过程计算一样，
对于一种给定的数据结构，也可以有许多方式将其表示为简单对象的组合，
而这种表示的选择，有可能对操作这些数据的计算过程的时间和空间需求造成重大的影响。
将在符号微分、集合的表示和信息编码的上下文中研究。

随后转去处理一个程序的不同部分可能采用不同的表示的数据的问题。实现通用型操作的需要，这种操作必须能处理许多不同的数据类型。
为了维持模块性，通用型操作的出现，将要求比只有简单数据抽象更强大的抽象屏障。
介绍数据导向的程序设计。这是一种允许我们孤立地设计每一种数据表示，而后添加的方式将它们组合进去。
将用已经学到的东西实现一个多项式符号算术的程序包，其中包括多项式的系数可以是整数、有理数、复数，甚至还可以是其它多项式。


## 2.1 数据抽象导引
可以这样造成一种抽象，它将一过程的使用方式，与该过程究竟如何通过更基本的过程实现的具体细节相互分离。针对复合数据的类似概念被称为数据抽象。
数据抽象是一种方法学，使我们可以将一个复合数据对象的使用，与该数据对象怎样由更基本的数据对象构造起来的细节隔离开。

数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在“抽象数据”上操作一样。
使用数据的方式是除了完成当前工作所必要的东西之外，不对所用数据做任何多余的假设。
一种“具体”数据表示的定义，也应该与程序中使用数据的方式无关。
两个部分之间的界面是一组过程，称为选择函数和构造函数，它们在具体表示之上实现抽象的数据。

### 2.1.1 实例：有理数的算术运算
假定希望做有理数上的算术，能做有理数的加减乘除运算，比较两个有理数是否相等。
开始：假定已经有一种从分子和分母构造有理数的方法。进一步，如果有了一个有理数，有一种方法取得它的分子和分母。
现在假定有关的构造函数和选择函数都可以作为过程使用：
- makeRat(n,d) 返回一个有理数，其分子是整数n，分母是整数d
- numer(x) 返回有理数x的分子
- denom(x) 返回有理数x的分母
这里使用一种称为按愿望思维的强有力的综合策略。现在思考如何去表示一个有理数，以及过程numer,denom和makeRat应如何实现。
如果我们真的有了这三个过程，那么就可以对有理数进行加减乘除和相等判断了。
实现过程如下：
```js
//有理数相加
function addRat(x,y){
    return makeRat(numer(x)*denom(y)+denom(x)*numer(y),denom(x)*denom(y));
}
//
function subRat(x,y){
    return makeRat(numer(x)*denom(y)-denom(x)*numer(y),denom(x)*denom(y));
}
//
function mulRat(x,y){
    return makeRat(numer(x)*numer(y),denom(x)*denom(y));
}
//
function divRat(x,y){
    return makeRat(numer(x)*denom(y),denom(x)*numer(y));
}
//
function equalRat(x,y){
    return numer(x)*denom(y)===denom(x)*numer(y);
}
```
这里已经有了定义在选择和构造过程numer、denom和makeRat基础之上的各种有理数运算，而这些基础还没有定义。
现在需要某种方式将一个分子和一个分母粘接起来，构成一个有理数。

序对 
具体层面上实现这一数据抽象，序对的复合结构，这种结构通过基本过程cons构造出来。过程cons取两个参数，返回一个包含这两个参数作为其成分的复合数据对象。
如果给了一个序对，可以用基本过程car和cdr，按如下方式提取出其中各个部分：
```js
```
一个序对也是一个数据对象，可以像基本数据对象一样给它一个名字且操作它。还可以用cons去构造那种其元素就是序对的序对，并且继续这样做下去。

序对可以用作构造任意种类的复杂数据结构的通用的基本构件。通过过程cons,car,cdr实现的这样一种最基本的复合数据，序对，也就是我们需要的所有东西。
从序对构造起来的数据对象称为表结构数据。

在js里只能用对象字面量来描述。
```js
var x={
    numer:1,
    denom:2
};
function car(x){
    return x.numer;
}
function cdr(x){
    return x.denom;
}
```
有理数的表示

序对完成这里的有理数系统提供了一种自然方式，可以将有理数简单表示为两个整数的序对。这样很容易做出makeRat,numer,denom的实现：
```js
function makeRat(x,y){
    return {
        numer:x,
        denom:y
    }
}
function numer(x){
    return car(x);
}
function denom(x){
    return cdr(x);
}
```
显示有理数的计算结果，将有理数打印为一个分子，在斜线符之后打印相应的分母。
```js
function printRat(x){
    console.log('\n');
    console.log(numer(x));
    console.log('/');
    console.log(denom(x));
}
var oneHalf=makeRat(1,2);
printRat(oneHalf);

var oneThird=makeRat(1,3);
printRat(oneThird);

printRat(addRat(oneHalf,oneThird));
printRat(mulRat(oneHalf,oneThird));
printRat(addRat(oneThird,oneThird));
```
有理数并没有将有理数约化到最简形式，通过修改makeRat可以很容易做到。要以使用最大公约数。
```js
function makeRat(x,y){
    var g=gcd(x,y);
    return {
        numer:x/g,
        denom:y/g
    };
}

printRat(addRat(oneThird,oneThird));
```

练习 2.1

 







