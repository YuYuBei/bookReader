简单的数值数据，对于解决许多问题而言，是不够的。
许多程序在设计时就是为了模拟复杂的对象，需要构造起一些计算对象，这些对象都是由一些部分组成的，以便去模拟真实世界里的那些具有若干侧面的对象。

 ## 将数据对象组合起来，形成复合数据的方式
 #### 为什么在程序设计语言里需要复合数据？
 为了提升在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。

### 设计一个系统，它完成有理数的算术
有理数：是一个整数a和一个非零整数b的比。有理数是整数和分数的集合。
```js
//a,b为两个有理数
function addRat(a,b){

}
```
分析：
 方法1､
 从基本数据出发，一个有理数可以看作两个整数，一个分子和一个分母。
 我们可以设计出一个程序，其中的每个有理数用两个整数表示，而其中addRat用两个过程实现。
 缺点：这样做会使我们必须明确地始终记住哪个分子与哪个分母相互对应。在需要执行大量有理数操作的系统里，这样的记录将会严重地扰乱我们的程序，而且这些麻烦又与我们真正想做的事情无关。

方法2､
如果将分子和分母“粘在一起”，形成一个对偶--复合数据对象--事情就会简单起来。程序中对有理数的操作可以将它们作为一个概念单位的方式进行。
复合数据的使用使我们进一步提高程序的模块性。
可以直接将有理数做为对象的方式操作。可以把处理有理数的那些程序，与有理数如何表示的细节隔离开。
这种将程序中处理数据对象的表示部分，与处理数据对象的使用部分相互隔离的技术，非常具有一般性，形成了一种称为数据抽象的设计方法学。
数据抽象技术可以使程序的设计、维护和修改更加的容易。

复合对象的使用将提高设计语言的表达能力。

形成“线性组合”ax+by，可以想到写一个过程，让它接受a,b,x和y作为参数并返回ax+by的值。如果以数值为参数，可以定义下面的函数：
```js
function linearCombination(a,b,x,y){
    return a*x+b*y;
}
```
如果我们关心的不仅仅是数，假定在写这个过程时，希望表述的是基于加和乘形成线性组合的思想，所针对的可以是有理数、复数、多项式或其他东西。我们可以把这个定义为下面这个函数：
```js
function linearCombination(a,b,x,y){
    return add(mul(a,x),mul(b,y));
}
```
其中add和mul不是基本的操作过程，而是更复杂的东西，它们能对通过参数a,b,x,和y送来的任何种类的数据执行适当的操作。
从linearCombination的角度看，a,b,x和y究竟是什么，并不重要，至于它们是怎样基于更基本的数据表示更没什么关系了。

为什么一种程序设计语言能够提供直接操作复合对象的能力是如此重要
因为如果没有这个能力，我们就没有办法让过程将其参数传递给其他过程，而不必知道这些参数的具体细节结构。

使用数据抽象在程序的不同部分之间建立起适当的数据屏障。
形成复合数据的关键在于，如何把一些数据对象组合起来，形成更复杂的数据对象。
怎样去构造出根本没有任何特定“数据”操作，只是由过程形成的复合数据。进一步模糊“过程”和“数据”之间的划分。

探索表示序列和树的一些常规技术。
在处理复合数据中的一个关键性思想是闭包的概念。
用于组合数据对象的方法，不但能组合基本的数据对象，同样可以用于复合的数据对象。

另一个思想是，复合数据对象能够成为以混合与匹配的方式组合程序模块的方便界面。
利用闭包概念的简单图形语言的方式，阐释有关的思想。

引用符号表达式，进一步扩大语言的表述能力。符号表达式的基本部分可以是任意的符号，不一定是数。

探索表示对象集合的各种不同方式，由此可以发现，一个给定的数学函数可以通过许多不同的计算过程计算一样，
对于一种给定的数据结构，也可以有许多方式将其表示为简单对象的组合，
而这种表示的选择，有可能对操作这些数据的计算过程的时间和空间需求造成重大的影响。
将在符号微分、集合的表示和信息编码的上下文中研究。

随后转去处理一个程序的不同部分可能采用不同的表示的数据的问题。实现通用型操作的需要，这种操作必须能处理许多不同的数据类型。
为了维持模块性，通用型操作的出现，将要求比只有简单数据抽象更强大的抽象屏障。
介绍数据导向的程序设计。这是一种允许我们孤立地设计每一种数据表示，而后添加的方式将它们组合进去。
将用已经学到的东西实现一个多项式符号算术的程序包，其中包括多项式的系数可以是整数、有理数、复数，甚至还可以是其它多项式。


## 2.1 数据抽象导引
可以这样造成一种抽象，它将一过程的使用方式，与该过程究竟如何通过更基本的过程实现的具体细节相互分离。针对复合数据的类似概念被称为数据抽象。
数据抽象是一种方法学，使我们可以将一个复合数据对象的使用，与该数据对象怎样由更基本的数据对象构造起来的细节隔离开。

数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在“抽象数据”上操作一样。
使用数据的方式是除了完成当前工作所必要的东西之外，不对所用数据做任何多余的假设。
一种“具体”数据表示的定义，也应该与程序中使用数据的方式无关。
两个部分之间的界面是一组过程，称为选择函数和构造函数，它们在具体表示之上实现抽象的数据。

### 2.1.1 实例：有理数的算术运算
假定希望做有理数上的算术，能做有理数的加减乘除运算，比较两个有理数是否相等。
开始：假定已经有一种从分子和分母构造有理数的方法。进一步，如果有了一个有理数，有一种方法取得它的分子和分母。
现在假定有关的构造函数和选择函数都可以作为过程使用：
- makeRat(n,d) 返回一个有理数，其分子是整数n，分母是整数d
- numer(x) 返回有理数x的分子
- denom(x) 返回有理数x的分母
这里使用一种称为按愿望思维的强有力的综合策略。现在思考如何去表示一个有理数，以及过程numer,denom和makeRat应如何实现。
如果我们真的有了这三个过程，那么就可以对有理数进行加减乘除和相等判断了。
实现过程如下：
```js
//有理数相加
function addRat(x,y){
    return makeRat(numer(x)*denom(y)+denom(x)*numer(y),denom(x)*denom(y));
}
//
function subRat(x,y){
    return makeRat(numer(x)*denom(y)-denom(x)*numer(y),denom(x)*denom(y));
}
//
function mulRat(x,y){
    return makeRat(numer(x)*numer(y),denom(x)*denom(y));
}
//
function divRat(x,y){
    return makeRat(numer(x)*denom(y),denom(x)*numer(y));
}
//
function equalRat(x,y){
    return numer(x)*denom(y)===denom(x)*numer(y);
}
```
这里已经有了定义在选择和构造过程numer、denom和makeRat基础之上的各种有理数运算，而这些基础还没有定义。
现在需要某种方式将一个分子和一个分母粘接起来，构成一个有理数。

序对 
具体层面上实现这一数据抽象，序对的复合结构，这种结构通过基本过程cons构造出来。过程cons取两个参数，返回一个包含这两个参数作为其成分的复合数据对象。
如果给了一个序对，可以用基本过程car和cdr，按如下方式提取出其中各个部分：
```js
```
一个序对也是一个数据对象，可以像基本数据对象一样给它一个名字且操作它。还可以用cons去构造那种其元素就是序对的序对，并且继续这样做下去。

序对可以用作构造任意种类的复杂数据结构的通用的基本构件。通过过程cons,car,cdr实现的这样一种最基本的复合数据，序对，也就是我们需要的所有东西。
从序对构造起来的数据对象称为表结构数据。

在js里只能用对象字面量来描述。
```js
var x={
    numer:1,
    denom:2
};
function car(x){
    return x.numer;
}
function cdr(x){
    return x.denom;
}
```
有理数的表示

序对完成这里的有理数系统提供了一种自然方式，可以将有理数简单表示为两个整数的序对。这样很容易做出makeRat,numer,denom的实现：
```js
function makeRat(x,y){
    return {
        numer:x,
        denom:y
    }
}
function numer(x){
    return car(x);
}
function denom(x){
    return cdr(x);
}
```
显示有理数的计算结果，将有理数打印为一个分子，在斜线符之后打印相应的分母。
```js
function printRat(x){
    console.log('\n');
    console.log(numer(x));
    console.log('/');
    console.log(denom(x));
}
var oneHalf=makeRat(1,2);
printRat(oneHalf);

var oneThird=makeRat(1,3);
printRat(oneThird);

printRat(addRat(oneHalf,oneThird));
printRat(mulRat(oneHalf,oneThird));
printRat(addRat(oneThird,oneThird));
```
有理数并没有将有理数约化到最简形式，通过修改makeRat可以很容易做到。要以使用最大公约数。

```js
function makeRat(x,y){
    var g=gcd(x,y);
    return {
        numer:x/g,
        denom:y/g
    };
}

printRat(addRat(oneThird,oneThird));
```

练习 2.1 定义makeRat的一个更好的版本，使之可以正确处理正数和负数。
当有理数是正时，makeRat应当将其规范化，使它的分子和分母都是正的。如果有理数为负时，那么应当只让分子为负。

```js
function makeRat(x,y){
    if(x<0 && y<0){
        x=-x;
        y=-y;
    }
    if(x*y<0 && x>0 ){
        x=-x;
        y=-y;
    }
    return {
        numer:x,
        denom:y
    }
}
```

### 2.1.2 抽象屏障
所有有理数的操作都是基于构造makeRat和选择函数numer,denom定义出来的。
数据抽象的基本思想是为每一类数据对象标识出一组操作，使得以这类数据对象的所有操作都可以基于它们表述，而且在操作这些数据对象时也只使用它们。
在每一层上，这种屏障都把使用数据抽象的程序（上面）与实现数据抽象的程序（下面）分开来。
使用有理数的程序将仅仅通过有理数包提供给“公众使用”的那些过程（addRat,subRat,mulRat,divRat和equalRat）去完成对有理数的各种操作；
这些过程转而又是完全基于构造函数和选择函数实现的；而这些又是基于序对实现的。
只要序对可以通过cons,car,cdr操作，有关序对如何实现的细节与有理数包的其余部分都完全没有关系。
从作用上看，每一层次中的过程构成了所定义的抽象屏障的界面，联系起系统中的不同层次。

这一简单思想的优点：
- 使程序很容易维护和修改。任意一种比较复杂的数据结构，都可以以多种不同方式用程序设计语言所提供的基本数据结构表示。
表示方式的选择会对操作它的程序产生影响，如果后来表示方式改变了，所有受影响的程序也都需要随之改变。
大型程序而言，这样的工作很耗时，而且代价极其昂贵，除非在设计时就已经将依赖于表示的成分限制到很少的一些程序模块上。

有理数约化到最简形式的工作，也完全可以不在构造的时候做，而是每次访问有理数中有关部分时做。这样就会导致另一套不同的构造函数和选择函数。

```js
function makeRat(x,y){
    return {
        numer:x,
        denom:y
    }
}
function numer(x){
    var g=gcd(car(x),cdr(x));
    return car(x)/g;
}
function denom(x){
    var g=gcd(car(x),cdr(x));
    return cdr(x)/g;
}
```
如果需要多次访问一个有理数的分子和分母，那么最好是在构造函数中计算gcd。如果不是这样，可以把gcd的计算推迟到访问时。
数据抽象方法使我们可以决定什么时间去决策，而不阻碍系统其他部分的工作进展。

练习 2.2
表示平面上线段的表示问题。一个线段用一对点表示，它们分别是线段的始点和终点。
定义makeSegment和选择函数startSegment,endSegment,它们基于点定义线段的表示。
一个点用数的序对表示，序对的两个成分分别表示点的x和y坐标。
进一步定义出构造函数makePoint和选择函数xPoint,yPoint，用它们定义出点的这种表示。最后，基于所定义的构造函数和选择函数，定义出函数midPointSegment,它以一个线段为参数，返回线段的中点。

```js
function makeSegment(p1,p2){
    return {
        startSegment:p1,
        endSegment:p2
    }
}
function startSegment(s){
    return s.startSegment;
}
function endSegment(s){
    return s.endSegment;
}

function makePoint(x,y){
    return {
        xPoint:x,
        yPoint:y
    }
}
function xPoint(p){
    return p.xPoint;
}
function yPoint(p){
    return p.yPoint;
}

function midPointSegment(s){
    var sp=startSegment(s);
    var ep=endSegment(s);
    return makePoint(Math.abs(xPoint(ep)-xPoint(sp))/2,Math.abs(yPoint(ep)-yPoint(sp))/2);
}
```

练习 2.3 实现一个平面矩形的表示。基于构造函数和选择函数定义几个过程，计算给定矩形的周长和面积等。

```js
//基于2.2
function makeRect(s1,s2){
    var s1StartPoint=startSegment(s1);
    var s1EndPoint=endSegment(s1);
    var s1StartPointX=xPoint(s1StartPoint);
    var s1StartPointY=yPoint(s1StartPoint);
    var s1EndPointX=xPoint(s1EndPoint);
    var s1EndPointY=yPoint(s1EndPoint);

    var s2StartPoint=startSegment(s2);
    var s2EndPoint=endSegment(s2);
    var s2StartPointX=xPoint(s2StartPoint);
    var s2StartPointY=yPoint(s2StartPoint);
    var s2EndPointX=xPoint(s2EndPoint);
    var s2EndPointY=yPoint(s2EndPoint);

    var w,h,x,y;
    if(s1StartPointX==s1EndPointX){
        h=Math.abs(s1EndPointY-s1StartPointY);
        w=Math.abs(s2EndPointX-s2StartPointX);
        x=s1StartPointX;
        y=s2StartPointY;
    }else{
        x=s2StartPointX;
        y=s1StartPointY;
        h=Math.abs(s2EndPointY-s2StartPointY);
        w=Math.abs(s1EndPointX-s1StartPointX);
    }
    var p=makePoint(x,y);
   
    return {
        point:p,
        width:w,
        height:h
    }
}
function perimeterRect(r){
    return wRect(r)*2+hRect(r)*2
}
function areaRect(r){
    return wRect(r)*hRect(r);
}
//另一种表示
function makeRect(p,w,h){
    return {
        point:p,
        width:w,
        height:h
    }
}
function wRect(r){
    return r.width;
}
function hRect(r){
    return r.height;
}
```

### 2.1.3 数据意味着什么
一般而言，我们总可以将数据定义为一组适当的选择函数和构造函数，以及使这些过程成为一套合法表示，它们就必须满足的一组特定条件。
如果用cons将两个对象粘接到一起，那么就可以借助于car和cdr提取出这两个对象。也就是说，这些操作满足条件是：对任何对象x和y，如果z是cons(x,y)那么
car z就是x，cdr z就是y。任何能满足上述条件的三个过程都可以成为实现序对的基础。

```js
function cons(x,y){
    return function(m){
        if(m==0)return x;
        if(m==1)return y;
        throw new Error('参数不对！');
    }
}
function car(x){
    return x(0);
}
function cdr(x){
    return x(1);
}
```

这里cons返回的值是一个过程，与之对应的car,cdr返回的我们需要序对提供的。序对的这一过程实现确实是合法的实现。
这一实例说明可以将过程作为对象去操作，因此就自动地为我们提供了一种表示复合数据的能力。
数据的过程性表示在程序设计中扮演一种核心角色。有关的程序设计风格通常称为消息传递。

练习 2.4

```js
function cons(x,y){
    return function(m){
        return m(x,y);
    }
}
function car(z){
    return z(function(p,q){
        return p;
    });
}
function cdr(z){
    return z(function(p,q){
        return q;
    })
}
```

练习 2.5

```js
/*
   构造函数，a,b产生2^a*3^b;
*/
function cons(a,b){
    return expt(2,a)*expt(3,b);
}
// a=2^a*3^b/2的次数
function car(z){
    if(z%2==0){
        return 1+car(z/2);
    }else{
        return 0;
    }
}
// b=2^a*3^b/3的次数
function cdr(z){
    if(z%3==0){
        return 1+cdr(z/3);
    }else{
        return 0;
    }
}
```
练习 2.6 在可以对过程做各种操作的语言里，可以将0和加一操作实现为

```js
function zero(){
    return function(f){
        return function(x){
            return x;
        }
    }
}

function add1(n){
    return function(f){
        return function(x){
            return f(n(f)(x));
        }
    }
}

//one = add1(zero);
var one=add1(function(f){
    return function(x){
        return x;
    }
})

var one=function(f){
    return function(x){
        return f(function(f){
            return function(x){
                return x;
            }
        }(f)(x));
    }
}
var one=function(f){
    return function(x){
        return f(x);
    }
}
//two=add1(one);
var two=add1(one);
var two=add1(function(f){
    return function(x){
        return f(x);
    }
});
var two=function(f){
    return function(x){
        return f(function(f){
            return function(x){
                return f(x);
            }
        }(f)(x));
    }
}
var two=function(f){
    return function(x){
        return f(f(x));
    }
}

//实现加法,累积两个参数的f的调用次数
function add(a1,a2){
    return function(f){
        return function(x){
               return a1(f)(a2(f)(x)))
        }
    }
    
}
//完成three=one+two
var three=add(two,one);
var three=add(function(f){
    return function(x){
        return f(f(x));
    }
},function(f){
    return function(x){
        return f(x);
    }
});
var three=function(f){
    return function(x){
           return function(f){
                return function(x){
                    return f(f(x));
                }
            }(f)(function(f){
                return function(x){
                    return f(x);
                }
            }(f)(x));
    }
}

var three=function(f){
    return function(x){
        return function(x){
           return function(f){
                return function(x){
                    return f(f(x));
                }
            }(f)(f(x));
        }
     }
}
var three=function(f){
    return function(x){
        return f(f(f(x)));
    }
}
```

### 2.1.4 扩展练习：区间算术
设计一个求解工程问题的系统。这个系统可以能够去操作不准确的量，这种量具有已知的精度，在对这种近似值进行计算时，得到的结果也应该是已知精度的数值。
电子工程师，使用系统计算一些电子量。有时必须使用下面公式，从两个电阻R1和R2计算出并联等价电阻Rp的值：
Rp=1/(1/R1+1/R2)
所知的电阻值通常是由电阻生产厂商给出的误差保证的值。
如：
6.8欧姆误差10%的电阻，其电阻值的范围是6.8-0.68=6.12到6.8+0.68=7.48之间。
如果把这个电组和一个4.7欧姆误差为5%的电阻并联，这一组合的电阻值在2.58欧姆到2.97欧姆之间。
实现一套“区间算术”，即作为可用于组合的“区间”的一组算术运算。两个区间的加、减、乘、除的结果仍是一个区间，表示的是计算结果的范围。

称为区间的抽象对象，这个对象的两个端点，一个是下界和一个上界。
给一个区间的两个端点，就可以用数据结构构造函数makeInterval构造出相应的区间来。

区间加法

```js
function addInterval(x,y){
    return makeInterval(lowerBound(x)+lowerBound(y),upperBound(x)+upperBound(y));
}


```

 







