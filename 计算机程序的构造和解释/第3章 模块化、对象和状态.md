组织大型程序的方式会受到我们对于被模拟系统的认识的支配。
两种特点鲜明的组织策略：
- 将注意力集中在对象上，将一个大型系统看成一大批对象，它们的行为可能随着时间的进展而不断变化。
- 将注意力集中在流过系统的信息流上，非常像电子工程师观察一个信号处理系统。

对于对象途径，必须关注计算对象可以怎样变化而又同时保持其标识。这迫使我们抛弃老的计算的代换模型，转向更机械的，理论上也更不容易把握的计算的环境模型。
在处理对象、变化和标识时，各种困难的基本根源在于我们需要在这一计算模型中与时间搏斗。

流方式特别能够用于松解在模型中对时间的模拟与计算机求值过程中的各种事件发生的顺序。通过使用一种延时求值的技术做到。

## 3.1 赋值和局部状态
我们对于世界的常规观点，就是将它看作聚集在一起的许多独立对象，每个对象都有自己的随着时间变化的状态。
所谓一个对象“有状态”，它的行为受到它的历史的影响。

例如：一个银行帐户就具有状态，对问题“我能取出100元钱吗？”的回答依赖于它的存入和支取的交易历史。
可以用一个或几个状态变量刻画一个对象的状态，在它们之中维持着有关这一对象的历史，即能确定该对象当前行为的充分的信息。
在一个简单的银行系统里，我们可以用当前余额刻画一个账户的状态，而不必记住这个账户的全部交易历史。

在一个由许多对象组成的系统里，其中这些对象很少是完全独立的。
每个对象都可能通过交互作用，影响其他对象的状态，所谓交互就是建立一个对象的状态变量与其他对象的状态变量之间的联系。
如果一个系统中的状态变量可以分组，形成一些内部紧密结合的子系统，每个子系统与其他子系统之间只存在松散联系，可以把这个系统看作是由一些独立对象组成的。

对于一个系统的以上观点，有可能成为组织这一系统的计算模型的有力框架。
要使这样的一个模型成为模块化的，就要求它能分解为一批计算对象，使它们能够模拟系统里的实际对象。
每一个计算对象必须有它自己的一些局部状态变量，用于描述实际对象的状态。
由于被模拟系统里的对象的状态是随着时间变化的，与它们相对应的计算对象的状态也必须变化。


如果确定要通过计算机里的时间顺序去模拟实际系统里时间的流逝，那么就必须构建起一些计算对象，使它们的行为随着程序的运行而改变。
如果我们希望通过程序设计语言里常规的符号名字去模拟状态变量，那么语言里必须提供一个赋值运算符，使我们能用它改变一个名字相关的值。

### 3.1.1 局部状态变量
说明计算对象具有随着时间变化的状态。
从一个银行账户支取现金的情况做一个模拟。

withdraw 完成现金的支取，它有一个amount参数，表示要支取的现金量。
如果账户有足够的余额，则返回支取后账户的款额，否则返回金额不足。
假设账户有 100元

```
(withdraw 25)
75
(withdraw 25)
50
(withdraw 60)
"金额不足！"
(withdraw 15)
35
```
局部状态变量，用于保存状态的变化轨迹。

一旦在语言里引进赋值，代换就不再适合作为过程应用的模型。需要为过程应用开发一个新模型。
//todo:这里有很多代码

以一个“消息”作为输入，返回这局部过程。消息传递风格。这里将它与修改局部变量的功能一起使用。

练习 3.1
练习 3.2
练习 3.3
练习 3.4

### 3.1.2 引进赋值带来的利益
将系统看作是一集带有局部状态的对象，也是一种维护模块化的强有力技术。
设计一个过程rand,每次调用时就会返回一个随机选出的整数。
产生出一系列的具有均匀分布的统计性质。
假定有一个过程rand-update，如果从一个数x1开始，执行下面操作
x2=randupdate(x1);
x3=randupdate(x2);
得到的值序列x1,x2,x3,...具有希望的性质。

```js
function rand(){
    var x=randomInit();
    return function (){
        x=randUpdate(x);
        return x;
    }
}
```
可以简单地直接调用randUpdate，生成同样的随机数序列。
但这意味着任何使用随机数的部分都必须显式地记住，需要将x的当前值送给randUpdate作为参数。
实现蒙特卡罗方法
从一个大集合里随机里随机选择试验样本，并在对这些试验结果的统计估计的基础上做出推断。
monteCarlo，它以做某个试验的次数，以及这个是试验本身作为参数。有关试验用一个无参过程表示，返回的是每次运行的结果为真或假。
monteCarlo运行这个试验指定的次数，它返回一个值，告知在所做的这些试验中得到真的比例。

```js
function estimatePI(trials){
    return Math.sqrt(6/monteCarlo(trials,cesaroTest));
}

function cesaroTest(){
    return gcd(rand(),rand())==1;
}
function monteCarlo(trials,experiment){
    function iter(trialsRemaining,trialsPassed){
        if(trialsRemaining==0)return trialsPassed/trials;
        if(experiment()){
            return iter(trialsRemaining-1,trialsPassed+1);
        }
        return iter(trialsRemaining-1,trialsPassed);
    }
    return iter(trials,0);
}
//不使用赋值去模拟局部状态,直接使用randUpdate
function estimatePI(trials){
    return Math.sqrt(6/randomGCDTest(trials,randomInit));
}

function randomGCDTest(trials,initialx){
    function iter(trialsRemaining,trialsPassed,x){
        var x1=randUpdate(x);
        var x2=randUpdate(x1);
        if(trialsRemaining==0)return trialsPassed/trials;
        if(gcd(x1,x2)==1){
            return iter(trialsRemaining-1,trialsPassed+1,x2);
        }
        return iter(trialsRemaining-1,trialsPassed,x2);
    }
    return iter(trials,0,initialx);
}

```

普遍性的现象：
从一个复杂计算过程中一部分的观点看，其他部分都像是在随着时间不断变化，它们隐藏起自己的随时间变化的内部状态。

假设我们希望写出一个计算机程序，反应这种系统分解，那么就需要让计算对象的行为随着时间变化，用局部状态变量去模拟系统的状态，
用对这些变量的赋值去模拟状态的变化。

总结：
与所有状态都必须显式地操作和传递额外参数的方式相比，通过引进赋值和将状态隐藏在局部变量中的技术，使我们能以一种更模块化的方式构造系统。

练习 3.5
练习 3.6


### 3.1.3 引进赋值的代价
不能再用过程应用的代换模型。
任何具有“漂亮”数学性质的简单模型，都不可能继续适合作为处理程序设计语言里的对象和赋值的框架。
只要我们不使用赋值，以同样参数对同一过程的两次求值一定产生出同样的结果，因此就可以认为过程是在计算数学函数。
不用任何赋值的程序设计称为函数式程序设计。

```js

function makeSimplifiedWidthdraw(balance){
    return function (amount){
        balance-=amount;
        return balance;
    }
}
var w=makeSimplifiedWidthdraw(100);
w(20);
80
w(10)
70


function makeDecrementer(balance){
    return function(amount){
        return balance-amount;
    }
}
var v=makeDecrementer(100);
v(20);
80
v(10)
90
```
不使用赋值，不会产生累积的结果。
当使用代换模型，必须对变量赋值的前后中两个状态进行区分。一个变量就不再是一个简单的名字。
现在一个变量索引着一个可以保存值的位置，而存储在那里的值也是可以改变的。

同一和变化
首先考虑两个物体实际上“同一”的概念。
假定同样的参数调用makeDecremeter两次，就会创建两个过程：

```js
var d1=makeDecrementer(25);
var d2=makeDecrementer(25);
```
d1和d2是同一的吗？
“是”是一个可以接受的回答，因为d1和d2具有同样的计算行为。
可以在任何的计算中用d1代替d2而不会改变结果。

与此对应的

```js
var w1=makeSimplifiedWidthdraw(25);
var w2=makeSimplifiedWidthdraw(25);
```
w1和w2是同一的吗？
显然不是，因为对w1和w2的调用会有不同的结果。
虽然w1和w2都是对同样表达式的求值创建起的东西，从这个角度它们是“同一”。
但在任何表达式中用w1代替w2,会改变表达式的最终结果。


如果一个语言支持在表达式里“同一的东西可以相互替换”的观念，这样替换不会改变表达式的求值结果，这个语言就称为具有引用透明性。
在计算机语言中使用赋值后就打破了引用透明性，就使确定通过等价的表达式代换去简化表达式变成了一个异常错综复杂的问题。
由于这种情况，对使用赋值的程序做推理也将变得极其困难。

一旦抛弃了引用透明性，有关计算对象“同一”的意义问题就很难形式地定义清楚。

使用如下方式确定两个看起来同一的事物是否确实是“同一个东西”：改变其中的一个对象，去看另一个对象是否也同样改变了。

但是，如果不能通过观察“同一个”对象两次，看看一次观察中看到的某些对象性质与另一次不同，又怎么能说清楚一个对象是否“变化”了呢？
所以，如果没有有关“同一”的某些先验观念，我们也不能确定“变化”，而不能看到变化的影响又无法确定同一性。


如果绝不修改数据对象，那么就可以将一个复合数据对象完全看作是由其片段组成的一个整体。
如果出现了修改这一观点就不合法了，此时复合数据对象有了一个“标识”，而它又是与组成这一对象的各片段都不同的东西。

命令式程序设计的缺陷
与函数式程序设计相对应的，广泛采用赋值的程序设计被称为命令式程序设计。

一般而言，带有赋值的程序将强迫人们去考虑赋值的相对顺序，以保证每个语句所用的是被修改变量的正确版本。

如果考虑多并发执行的进程的应用程序，命令式程序设计的复杂性更糟糕。

练习 3.7

练习 3.8

## 3.2 求值的环境模型
第一章引进复合过程时，采用求值的代换模型定义了将过程应用于实际参数的意义。
- 将一个复合过程应用于一些实际参数，就是在用各个参数代换过程体里对应的形式参数之后，求值这个过程体。

由于赋值的存在，变量已经不能再看作仅仅是某个值的名字。此时的一个变量必须以某种方式指定一个“位置”，相应的值可以存储在那里。

在新求值模型里，这种位置将维持在称为环境的结构中。
一个环境就是框架的一个序列，每个框架是包含着一些约束的一个表格（可能为空），
这些约束将一些变量名字关联于对应的值（在一个框架里，任何变量至多只能有一个约束）。
每个框架还包含着一个指针，指向这一框架的外围环境。
如果当前讨论的目的，将相应的框架看作是全局的，那么它将没有外围环境。
一个变量相对于某个特定环境的值，也就是在这一环境中，包含着该变量的第一框架里这个约束值。
如果在序列中并不存在这一变量的约束，那么我们就说这个变量在该特定环境中是无约束的。

环境对于求值过程是至关重要的，因为它确定了表达式求值的上下文。

完全可以说，在一个程序语言里的一个表达式本身根本没有任何意义。
即使像 1+1 这样的表达式，其解释也要依赖于有关的操作是在某个上下文里进行的，在那里+是表示加法的符号。

讨论求值模型，将总说某个表达式相对于某个环境的求值。

为了描述与解释器的交互作用，将始终假定存在着一个全局环境，
它只包含着一个框架（没有外围环境），这个环境里包含着所有关联于基本过程的符号的值。

例如有关+是表示加法的符号这一观念，这里的表现就是，符号+在全局环境中被约束到相应的基本加法过程。

### 3.2.1 求值规则
关于解释器如何求值一个组合式的问题：
如果要对一个组合表达式求值：
1､求值这一组合式里的各个子表达式
2､将运算符子表达式的值应用于运算对象子表达式的值。

现在用求值的环境模型代替求值的代换模型，在这一模型里需要特别说明将一个复合过程应用于参数表示的是什么。

在求值的环境模型里，一个过程总是一个对偶，由一些代码和一个指向环境的指针组成。


创建过程

过程只能通过一种方式创建，就是通过求值一个lambda表达式。
这样产生出的过程的代码来自一个lambda表达式的正文，其环境就是求值这个lambda表达式，产生出这个过程时的那个环境。

```js
function square(x){
    return x*x;
}
//这只是一种语法糖衣，实际的产生过程
var square=(function(){
    return function(x){
        return x*x;
    }
})();

```
求值(function(){})();的过程都是在全局的环境中完成的。

代码部分的描述的是一个形式参数x的过程，过程体是return x*x。
过程对象的环境部分是一个指向全局环境的指针，因为产生这个过程的lambda表达式是在全局环境中求值的。
同时，这个定义在全局框架中加入一个新约束，将上述过程对象约束于符号square。
一般而言，function建立定义的方式就是将新的约束加入框架里。

过程的应用

环境模型说明：
在将一个过程应用于一组实际参数时，将会建立起一个新环境，
其中包含了将所有形式参数约束于对应的实际参数的框架，该框架的外围环境就是所用的这个过程的环境。
随后就在这个新环境之下求值过程的体。

过程应用的环境模型总结为以下两条规则：
- 将一个过程对象应用于一集实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的实际参数，而后在构造起的这一新环境的上下文中求值过程体。
这个新框架的外围环境就是作为被应用的那个过程对象的一部分的环境。
- 相对于一个给定环境求值一个lambda表达式，将创建起一个过程对象，这个过程对象是一个序对，由该lambda表达式的正文和一个指向环境的指针组成，
这一指针指向的就是创建这个过程对象时的环境。


define定义一个符号，就是在当前环境框架里建立一个约束，并赋予这个符号指定的值。
在某个环境中求值表达式，variable=value，要求我们首先在环境中确定有关变量的约束位置，而后再修改这个约束，使之表示这个新值。

 虽然这一求值模型比较抽象，但它却为解释器对于表达式求值的过程提供了一个正确的描述。

### 3.2.2 抽象过程的应用

```js
function square(x){
    return x*x;
}

function sumOfSquares(x,y){
    return square(x)+square(y);
}

function f(a){
    return sumOfSquares(a+1,a*2);
}

```

其中f,square,sumOfSquares是在全局环境中定义的三个过程对象，每个过程对象都由一些代码和一个指向全局环境的指针组成。

由f(5)的求值创建起的环境结构。对于f的调用创建了一个新环境，它开始于一个框架，其中f的形式参数a被约束到实参5。
需要在新环境里求值f的过程体：
sumOfSquares(a+1,a*2)
在求值这个组合式时，首先需要求值其中的子表达式。
第一个表达式sumOfSquares以一个过程对象为值。
对另外两个表达式的求值是应用两个基本运算符+和*，通过求值组合式，a+1,a*2分别得到6和10。
下面是把过程对象sumOfSquares应用于实参6和10。
这时得到的是一个新环境，形式参数x和y在其中约束于对应的实际参数。
现在需要在这个新环境中，求值组合式（square(x)+square(y))。
进一步要求我们求值square(x),其中的square从全局环境中找到，而x是6。

现在又设定另一个新环境，其中将x约束到6,并在这里求值square的体(x*x)。
作为sumOfSquares的另一部分，还必须求值子表达式square(y),其中y是10。
这里对square是第二个调用，它创建了另一个环境，其中square的形式参数x约束到10,在这个新环境中求值(x*x)。

对于square的每个调用都会创建一个包含着x的约束的新环境。
这里是通过不同的框架，去维持所有名字为x的局部变量互不相同。
注意：
由square创建的每个框架都指向全局环境，因为这就是对于square的过程对象所指定的环境。

各个表达式求值返回得到的值。对于square的两个调用产生的被sumOfSquares加起来，作为求值的结果返回。

练习 3.9


### 3.2.3 将框架看作局部状态的展台

### 3.2.4 内部定义

环境模型以局部过程定义作为程序模块化的有用的技术的两个关键性质：
- 局部过程的名字不会与包容它们的过程之外的名字互相干扰，因为这些局部过程名都是在该过程运行时创建的框架里面约束的，而不是全局环境里约束的。
- 局部过程只需将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数，这是因为对于局部过程体的求值所在的环境是外围过程求值所在的环境的下属。

练习 3.11

## 3.3 用变动数据做模拟
第二章以复合数据作为构造具有多个部分的计算对象的方法，用于模拟真实世界里具有若干不同侧面的对象。
各个数据结构应该用构造函数（用于创建数据对象）和选择函数（用于访问复合数据对象中的各个部分）来描述。

为了模拟那些由具有不断变化的状态组成的系统，除了需要做复合数据对象的构造和成分选择之外，还可能需要修改它们。

为了模拟具有不断变化的状态的复合对象，设计出与之对应的数据抽象，使其不但包含选择函数和构造函数，还包含改变函数的操作，
这种操作能够修改有关的数据对象。

定义了改变函数的数据对象称为变动数据对象。


### 3.3.1 变动的表结构
练习 3.12
练习 3.13
练习 3.14

共享和相等
练习 3.15
练习 3.16
练习 3.17
练习 3.18
练习 3.19

改变也是赋值
练习 3.20

### 3.3.2 队列的表示
练习 3.21
练习 3.22
练习 3.23

### 3.3.3 表格的表示

两维表格

创建局部表格
练习 3.24
练习 3.25
练习 3.26
练习 3.27

### 3.3.4 数字电路的模拟器

基本功能块

练习 3.28
练习 3.29
练习 3.30

线路的表示


待处理表

一个简单的实例模拟

练习 3.31

待处理表的实现

练习 3.32

### 3.3.5 约束的传播
一种语言的设计，使我们可以基于各种关系进行工作。
这个语言里的基本元素就是基本约束，它们描述了在不同量之间的某种特定关系。
通过构造约束网络组合起各种约束，约束通过连接器连接起来。

连接器是一种对象，它们可以“保存”一个值，使之能参与一个或者多个约束。
网络完成的计算如下方式进行：
当某个连接器被给定了一个值时（由用户或者由它所连接的某个约束块），它就会唤醒所有与之关联的约束，通知它们自己有一个新值。
被唤醒的每个约束块将去盘点自己的连接器，看看是否存在足够的信息为某个连接器确定一个值。
如果可能的话，该块就设置相应的连接器，而这个连接器又会唤醒与之连接的约束，并这样进行下去。

约束系统的使用

约束系统的实现

连接器的表示

练习 3.35
练习 3.36
练习 3.37

## 3.4 并发：时间是一个本质问题

赋值语句的执行描绘出有关值变化的一些时刻，对一个表达式的求值结果不但依赖于该表达式本身，还依赖于求值发生在这些时刻之前还是之后。
采用具有局部状态的计算对象建立模型，就会直面时间问题。

现实世界里的对象并不是一次一个地顺序变化，而是总是并发地活动，所有东西一起动。

### 3.4.1 并发系统中时间的性质

并发程序的正确行为
练习 3.38

### 3.4.2 控制并发的机制

对共享变量的串行访问
使进程可以并发地执行，但是其中也有一些过程不能并发地执行。
串行化就是创建一些不同的过程集合，并且保证在每个时刻，在任何一个串行化集合里至多只有一个过程的一个执行。

如果某个集合里有过程正在执行，而另一个进程企图执行这个集合里的任何过程时，它就必须等待到前一过程的执行结束。
可以借助串行化去控制对共享变量的访问。
如果我们希望基于某个共享变量已有的值去更新它，那么就应该将访问这一变量的现有值和给这一变量赋值的操作都放入同一个过程里。
而后设法保证，任何能给这个变量赋值的过程都不会与这个过程并发运行，方法是将所有这样的过程都放在同一个串行集合里。
这就保证了在访问一个变量和给它赋值之间，这一变量的值不会改变。

练习 3.39
练习 3.40
练习 3.41
练习 3.42

使用多重共享资源的复杂性

练习 3.43
练习 3.44
练习 3.45

串行化的实现
使用互斥元的同步机制来实现串行化。
互斥元是一种对象，一个互斥元可以被获取或被释放。

练习 3.46
练习 3.47

死锁
每个进程都要无穷无尽地等待另一个进程的活动，这种情况叫作死锁。

练习 3.48
练习 3.49

并发性、时间和通信









