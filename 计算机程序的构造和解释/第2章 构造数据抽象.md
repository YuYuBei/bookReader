简单的数值数据，对于解决许多问题而言，是不够的。
许多程序在设计时就是为了模拟复杂的对象，需要构造起一些计算对象，这些对象都是由一些部分组成的，以便去模拟真实世界里的那些具有若干侧面的对象。

 ## 将数据对象组合起来，形成复合数据的方式
 #### 为什么在程序设计语言里需要复合数据？
 为了提升在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。

### 设计一个系统，它完成有理数的算术
有理数：是一个整数a和一个非零整数b的比。有理数是整数和分数的集合。
```js
//a,b为两个有理数
function addRat(a,b){

}
```
分析：
 方法1､
 从基本数据出发，一个有理数可以看作两个整数，一个分子和一个分母。
 我们可以设计出一个程序，其中的每个有理数用两个整数表示，而其中addRat用两个过程实现。
 缺点：这样做会使我们必须明确地始终记住哪个分子与哪个分母相互对应。在需要执行大量有理数操作的系统里，这样的记录将会严重地扰乱我们的程序，而且这些麻烦又与我们真正想做的事情无关。

方法2､
如果将分子和分母“粘在一起”，形成一个对偶--复合数据对象--事情就会简单起来。程序中对有理数的操作可以将它们作为一个概念单位的方式进行。
复合数据的使用使我们进一步提高程序的模块性。
可以直接将有理数做为对象的方式操作。可以把处理有理数的那些程序，与有理数如何表示的细节隔离开。
这种将程序中处理数据对象的表示部分，与处理数据对象的使用部分相互隔离的技术，非常具有一般性，形成了一种称为数据抽象的设计方法学。
数据抽象技术可以使程序的设计、维护和修改更加的容易。

复合对象的使用将提高设计语言的表达能力。

形成“线性组合”ax+by，可以想到写一个过程，让它接受a,b,x和y作为参数并返回ax+by的值。如果以数值为参数，可以定义下面的函数：
```js
function linearCombination(a,b,x,y){
    return a*x+b*y;
}
```
如果我们关心的不仅仅是数，假定在写这个过程时，希望表述的是基于加和乘形成线性组合的思想，所针对的可以是有理数、复数、多项式或其他东西。我们可以把这个定义为下面这个函数：
```js
function linearCombination(a,b,x,y){
    return add(mul(a,x),mul(b,y));
}
```
其中add和mul不是基本的操作过程，而是更复杂的东西，它们能对通过参数a,b,x,和y送来的任何种类的数据执行适当的操作。
从linearCombination的角度看，a,b,x和y究竟是什么，并不重要，至于它们是怎样基于更基本的数据表示更没什么关系了。

为什么一种程序设计语言能够提供直接操作复合对象的能力是如此重要
因为如果没有这个能力，我们就没有办法让过程将其参数传递给其他过程，而不必知道这些参数的具体细节结构。

使用数据抽象在程序的不同部分之间建立起适当的数据屏障。
形成复合数据的关键在于，如何把一些数据对象组合起来，形成更复杂的数据对象。
怎样去构造出根本没有任何特定“数据”操作，只是由过程形成的复合数据。进一步模糊“过程”和“数据”之间的划分。

探索表示序列和树的一些常规技术。
在处理复合数据中的一个关键性思想是闭包的概念。
用于组合数据对象的方法，不但能组合基本的数据对象，同样可以用于复合的数据对象。

另一个思想是，复合数据对象能够成为以混合与匹配的方式组合程序模块的方便界面。
利用闭包概念的简单图形语言的方式，阐释有关的思想。

引用符号表达式，进一步扩大语言的表述能力。符号表达式的基本部分可以是任意的符号，不一定是数。

探索表示对象集合的各种不同方式，由此可以发现，一个给定的数学函数可以通过许多不同的计算过程计算一样，
对于一种给定的数据结构，也可以有许多方式将其表示为简单对象的组合，
而这种表示的选择，有可能对操作这些数据的计算过程的时间和空间需求造成重大的影响。
将在符号微分、集合的表示和信息编码的上下文中研究。

随后转去处理一个程序的不同部分可能采用不同的表示的数据的问题。实现通用型操作的需要，这种操作必须能处理许多不同的数据类型。
为了维持模块性，通用型操作的出现，将要求比只有简单数据抽象更强大的抽象屏障。
介绍数据导向的程序设计。这是一种允许我们孤立地设计每一种数据表示，而后添加的方式将它们组合进去。
将用已经学到的东西实现一个多项式符号算术的程序包，其中包括多项式的系数可以是整数、有理数、复数，甚至还可以是其它多项式。


## 2.1 数据抽象导引
可以这样造成一种抽象，它将一过程的使用方式，与该过程究竟如何通过更基本的过程实现的具体细节相互分离。针对复合数据的类似概念被称为数据抽象。
数据抽象是一种方法学，使我们可以将一个复合数据对象的使用，与该数据对象怎样由更基本的数据对象构造起来的细节隔离开。

数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在“抽象数据”上操作一样。
使用数据的方式是除了完成当前工作所必要的东西之外，不对所用数据做任何多余的假设。
一种“具体”数据表示的定义，也应该与程序中使用数据的方式无关。
两个部分之间的界面是一组过程，称为选择函数和构造函数，它们在具体表示之上实现抽象的数据。

### 2.1.1 实例：有理数的算术运算
假定希望做有理数上的算术，能做有理数的加减乘除运算，比较两个有理数是否相等。
开始：假定已经有一种从分子和分母构造有理数的方法。进一步，如果有了一个有理数，有一种方法取得它的分子和分母。
现在假定有关的构造函数和选择函数都可以作为过程使用：
- makeRat(n,d) 返回一个有理数，其分子是整数n，分母是整数d
- numer(x) 返回有理数x的分子
- denom(x) 返回有理数x的分母
这里使用一种称为按愿望思维的强有力的综合策略。现在思考如何去表示一个有理数，以及过程numer,denom和makeRat应如何实现。
如果我们真的有了这三个过程，那么就可以对有理数进行加减乘除和相等判断了。
实现过程如下：
```js
//有理数相加
function addRat(x,y){
    return makeRat(numer(x)*denom(y)+denom(x)*numer(y),denom(x)*denom(y));
}
//
function subRat(x,y){
    return makeRat(numer(x)*denom(y)-denom(x)*numer(y),denom(x)*denom(y));
}
//
function mulRat(x,y){
    return makeRat(numer(x)*numer(y),denom(x)*denom(y));
}
//
function divRat(x,y){
    return makeRat(numer(x)*denom(y),denom(x)*numer(y));
}
//
function equalRat(x,y){
    return numer(x)*denom(y)===denom(x)*numer(y);
}
```
这里已经有了定义在选择和构造过程numer、denom和makeRat基础之上的各种有理数运算，而这些基础还没有定义。
现在需要某种方式将一个分子和一个分母粘接起来，构成一个有理数。

序对 
具体层面上实现这一数据抽象，序对的复合结构，这种结构通过基本过程cons构造出来。过程cons取两个参数，返回一个包含这两个参数作为其成分的复合数据对象。
如果给了一个序对，可以用基本过程car和cdr，按如下方式提取出其中各个部分：
```js
```
一个序对也是一个数据对象，可以像基本数据对象一样给它一个名字且操作它。还可以用cons去构造那种其元素就是序对的序对，并且继续这样做下去。

序对可以用作构造任意种类的复杂数据结构的通用的基本构件。通过过程cons,car,cdr实现的这样一种最基本的复合数据，序对，也就是我们需要的所有东西。
从序对构造起来的数据对象称为表结构数据。

在js里只能用对象字面量来描述。
```js
var x={
    numer:1,
    denom:2
};
function car(x){
    return x.numer;
}
function cdr(x){
    return x.denom;
}
```
有理数的表示

序对完成这里的有理数系统提供了一种自然方式，可以将有理数简单表示为两个整数的序对。这样很容易做出makeRat,numer,denom的实现：
```js
function makeRat(x,y){
    return {
        numer:x,
        denom:y
    }
}
function numer(x){
    return car(x);
}
function denom(x){
    return cdr(x);
}
```
显示有理数的计算结果，将有理数打印为一个分子，在斜线符之后打印相应的分母。
```js
function printRat(x){
    console.log('\n');
    console.log(numer(x));
    console.log('/');
    console.log(denom(x));
}
var oneHalf=makeRat(1,2);
printRat(oneHalf);

var oneThird=makeRat(1,3);
printRat(oneThird);

printRat(addRat(oneHalf,oneThird));
printRat(mulRat(oneHalf,oneThird));
printRat(addRat(oneThird,oneThird));
```
有理数并没有将有理数约化到最简形式，通过修改makeRat可以很容易做到。要以使用最大公约数。

```js
function makeRat(x,y){
    var g=gcd(x,y);
    return {
        numer:x/g,
        denom:y/g
    };
}

printRat(addRat(oneThird,oneThird));
```

练习 2.1 定义makeRat的一个更好的版本，使之可以正确处理正数和负数。
当有理数是正时，makeRat应当将其规范化，使它的分子和分母都是正的。如果有理数为负时，那么应当只让分子为负。

```js
function makeRat(x,y){
    if(x<0 && y<0){
        x=-x;
        y=-y;
    }
    if(x*y<0 && x>0 ){
        x=-x;
        y=-y;
    }
    return {
        numer:x,
        denom:y
    }
}
```

### 2.1.2 抽象屏障
所有有理数的操作都是基于构造makeRat和选择函数numer,denom定义出来的。
数据抽象的基本思想是为每一类数据对象标识出一组操作，使得以这类数据对象的所有操作都可以基于它们表述，而且在操作这些数据对象时也只使用它们。
在每一层上，这种屏障都把使用数据抽象的程序（上面）与实现数据抽象的程序（下面）分开来。
使用有理数的程序将仅仅通过有理数包提供给“公众使用”的那些过程（addRat,subRat,mulRat,divRat和equalRat）去完成对有理数的各种操作；
这些过程转而又是完全基于构造函数和选择函数实现的；而这些又是基于序对实现的。
只要序对可以通过cons,car,cdr操作，有关序对如何实现的细节与有理数包的其余部分都完全没有关系。
从作用上看，每一层次中的过程构成了所定义的抽象屏障的界面，联系起系统中的不同层次。

这一简单思想的优点：
- 使程序很容易维护和修改。任意一种比较复杂的数据结构，都可以以多种不同方式用程序设计语言所提供的基本数据结构表示。
表示方式的选择会对操作它的程序产生影响，如果后来表示方式改变了，所有受影响的程序也都需要随之改变。
大型程序而言，这样的工作很耗时，而且代价极其昂贵，除非在设计时就已经将依赖于表示的成分限制到很少的一些程序模块上。

有理数约化到最简形式的工作，也完全可以不在构造的时候做，而是每次访问有理数中有关部分时做。这样就会导致另一套不同的构造函数和选择函数。

```js
function makeRat(x,y){
    return {
        numer:x,
        denom:y
    }
}
function numer(x){
    var g=gcd(car(x),cdr(x));
    return car(x)/g;
}
function denom(x){
    var g=gcd(car(x),cdr(x));
    return cdr(x)/g;
}
```
如果需要多次访问一个有理数的分子和分母，那么最好是在构造函数中计算gcd。如果不是这样，可以把gcd的计算推迟到访问时。
数据抽象方法使我们可以决定什么时间去决策，而不阻碍系统其他部分的工作进展。

练习 2.2
表示平面上线段的表示问题。一个线段用一对点表示，它们分别是线段的始点和终点。
定义makeSegment和选择函数startSegment,endSegment,它们基于点定义线段的表示。
一个点用数的序对表示，序对的两个成分分别表示点的x和y坐标。
进一步定义出构造函数makePoint和选择函数xPoint,yPoint，用它们定义出点的这种表示。最后，基于所定义的构造函数和选择函数，定义出函数midPointSegment,它以一个线段为参数，返回线段的中点。

```js
function makeSegment(p1,p2){
    return {
        startSegment:p1,
        endSegment:p2
    }
}
function startSegment(s){
    return s.startSegment;
}
function endSegment(s){
    return s.endSegment;
}

function makePoint(x,y){
    return {
        xPoint:x,
        yPoint:y
    }
}
function xPoint(p){
    return p.xPoint;
}
function yPoint(p){
    return p.yPoint;
}

function midPointSegment(s){
    var sp=startSegment(s);
    var ep=endSegment(s);
    return makePoint(Math.abs(xPoint(ep)-xPoint(sp))/2,Math.abs(yPoint(ep)-yPoint(sp))/2);
}
```

练习 2.3 实现一个平面矩形的表示。基于构造函数和选择函数定义几个过程，计算给定矩形的周长和面积等。

```js
//基于2.2
function makeRect(s1,s2){
    var s1StartPoint=startSegment(s1);
    var s1EndPoint=endSegment(s1);
    var s1StartPointX=xPoint(s1StartPoint);
    var s1StartPointY=yPoint(s1StartPoint);
    var s1EndPointX=xPoint(s1EndPoint);
    var s1EndPointY=yPoint(s1EndPoint);

    var s2StartPoint=startSegment(s2);
    var s2EndPoint=endSegment(s2);
    var s2StartPointX=xPoint(s2StartPoint);
    var s2StartPointY=yPoint(s2StartPoint);
    var s2EndPointX=xPoint(s2EndPoint);
    var s2EndPointY=yPoint(s2EndPoint);

    var w,h,x,y;
    if(s1StartPointX==s1EndPointX){
        h=Math.abs(s1EndPointY-s1StartPointY);
        w=Math.abs(s2EndPointX-s2StartPointX);
        x=s1StartPointX;
        y=s2StartPointY;
    }else{
        x=s2StartPointX;
        y=s1StartPointY;
        h=Math.abs(s2EndPointY-s2StartPointY);
        w=Math.abs(s1EndPointX-s1StartPointX);
    }
    var p=makePoint(x,y);
   
    return {
        point:p,
        width:w,
        height:h
    }
}
function perimeterRect(r){
    return wRect(r)*2+hRect(r)*2
}
function areaRect(r){
    return wRect(r)*hRect(r);
}
//另一种表示
function makeRect(p,w,h){
    return {
        point:p,
        width:w,
        height:h
    }
}
function wRect(r){
    return r.width;
}
function hRect(r){
    return r.height;
}
```

### 2.1.3 数据意味着什么
一般而言，我们总可以将数据定义为一组适当的选择函数和构造函数，以及使这些过程成为一套合法表示，它们就必须满足的一组特定条件。
如果用cons将两个对象粘接到一起，那么就可以借助于car和cdr提取出这两个对象。也就是说，这些操作满足条件是：对任何对象x和y，如果z是cons(x,y)那么
car z就是x，cdr z就是y。任何能满足上述条件的三个过程都可以成为实现序对的基础。

```js
function cons(x,y){
    return function(m){
        if(m==0)return x;
        if(m==1)return y;
        throw new Error('参数不对！');
    }
}
function car(x){
    return x(0);
}
function cdr(x){
    return x(1);
}
```

这里cons返回的值是一个过程，与之对应的car,cdr返回的我们需要序对提供的。序对的这一过程实现确实是合法的实现。
这一实例说明可以将过程作为对象去操作，因此就自动地为我们提供了一种表示复合数据的能力。
数据的过程性表示在程序设计中扮演一种核心角色。有关的程序设计风格通常称为消息传递。

练习 2.4

```js
function cons(x,y){
    return function(m){
        return m(x,y);
    }
}
function car(z){
    return z(function(p,q){
        return p;
    });
}
function cdr(z){
    return z(function(p,q){
        return q;
    })
}
```

练习 2.5

```js
/*
   构造函数，a,b产生2^a*3^b;
*/
function cons(a,b){
    return expt(2,a)*expt(3,b);
}
// a=2^a*3^b/2的次数
function car(z){
    if(z%2==0){
        return 1+car(z/2);
    }else{
        return 0;
    }
}
// b=2^a*3^b/3的次数
function cdr(z){
    if(z%3==0){
        return 1+cdr(z/3);
    }else{
        return 0;
    }
}
```
练习 2.6 在可以对过程做各种操作的语言里，可以将0和加一操作实现为

```js
function zero(){
    return function(f){
        return function(x){
            return x;
        }
    }
}

function add1(n){
    return function(f){
        return function(x){
            return f(n(f)(x));
        }
    }
}

//one = add1(zero);
var one=add1(function(f){
    return function(x){
        return x;
    }
})

var one=function(f){
    return function(x){
        return f(function(f){
            return function(x){
                return x;
            }
        }(f)(x));
    }
}
var one=function(f){
    return function(x){
        return f(x);
    }
}
//two=add1(one);
var two=add1(one);
var two=add1(function(f){
    return function(x){
        return f(x);
    }
});
var two=function(f){
    return function(x){
        return f(function(f){
            return function(x){
                return f(x);
            }
        }(f)(x));
    }
}
var two=function(f){
    return function(x){
        return f(f(x));
    }
}

//实现加法,累积两个参数的f的调用次数
function add(a1,a2){
    return function(f){
        return function(x){
               return a1(f)(a2(f)(x)))
        }
    }
    
}
//完成three=one+two
var three=add(two,one);
var three=add(function(f){
    return function(x){
        return f(f(x));
    }
},function(f){
    return function(x){
        return f(x);
    }
});
var three=function(f){
    return function(x){
           return function(f){
                return function(x){
                    return f(f(x));
                }
            }(f)(function(f){
                return function(x){
                    return f(x);
                }
            }(f)(x));
    }
}

var three=function(f){
    return function(x){
        return function(x){
           return function(f){
                return function(x){
                    return f(f(x));
                }
            }(f)(f(x));
        }
     }
}
var three=function(f){
    return function(x){
        return f(f(f(x)));
    }
}
```

### 2.1.4 扩展练习：区间算术
设计一个求解工程问题的系统。这个系统可以能够去操作不准确的量，这种量具有已知的精度，在对这种近似值进行计算时，得到的结果也应该是已知精度的数值。
电子工程师，使用系统计算一些电子量。有时必须使用下面公式，从两个电阻R1和R2计算出并联等价电阻Rp的值：
Rp=1/(1/R1+1/R2)
所知的电阻值通常是由电阻生产厂商给出的误差保证的值。
如：
6.8欧姆误差10%的电阻，其电阻值的范围是6.8-0.68=6.12到6.8+0.68=7.48之间。
如果把这个电组和一个4.7欧姆误差为5%的电阻并联，这一组合的电阻值在2.58欧姆到2.97欧姆之间。
实现一套“区间算术”，即作为可用于组合的“区间”的一组算术运算。两个区间的加、减、乘、除的结果仍是一个区间，表示的是计算结果的范围。

称为区间的抽象对象，这个对象的两个端点，一个是下界和一个上界。
给一个区间的两个端点，就可以用数据结构构造函数makeInterval构造出相应的区间来。



```js
//区间加法
function addInterval(x,y){
    return makeInterval(lowerBound(x)+lowerBound(y),upperBound(x)+upperBound(y));
}

//区间乘法
function mulInterval(x,y){
    var p1=lowerBound(x)*lowerBound(y);
    var p2=lowerBound(x)*upperBound(y);
    var p3=upperBound(x)*lowerBound(y);
    var p4=upperBound(x)*upperBound(y);
    return makeInterval(min(p1,p2,p3,p4),max(p1,p2,p3,p4));
}

//区间除法
function divInterval(x,y){
    return mulInterval(x,makeInterval(1/upperBound(y),1/lowerBound(y)));
}

```

练习 2.7

```js
function makeInterval(a,b){
    return function(m){
        if(m==0)return a;
        if(m==1)return b;
        throw new Error('不合法的参数！');
    }
} 
function lowerBound(x){
    return x(0);
}
function upperBound(x){
    return x(1);
}
```

练习 2.8

```js
//区间差
function subInterval(x,y){
    return makeInterval(max(lowerBound(x),lowerBound(y)),min(upperBound(x),upperBound(y)));
}
```

练习 2.9

```js
//区间宽度
function halfInterval(x){
    return (upperBound(x)-lowerBound(x))/2
}

/*
证明 halfInterval(addInterval(x,y)) == addInterval(halfInterval(x),halfInterval(y))
展开：halfInterval(addInterval(x,y))
halfInterval(makeInterval(lowerBound(x)+lowerBound(y),upperBound(x)+upperBound(y)))
upperBound(makeInterval(lowerBound(x)+lowerBound(y),upperBound(x)+upperBound(y)))-lowerBound(makeInterval(lowerBound(x)+lowerBound(y),upperBound(x)+upperBound(y)))/2
(upperBound(x)+upperBound(y)-lowerBound(x)-lowerBound(y))/2
(upperBound(x)-lowerBound(x))/2+(upperBound(y)-lowerBound(y))/2
与
addInterval(halfInterval(x),halfInterval(y))的展开式相同
同理可证减法。
由于乘除，无法根据参数区间的上下界去单一确定一个新的区间，所以其宽度也无法通过两个区间的宽度获得。
*/
```
 练习 2.10

 ```js
 function checkInterval(x){
     if(lowerBound(x)<0 && upperBound(x)>0){
         return false;
    }
     return true;
 }
```

练习 2.11

//todo:后面继续解题，先进行书的下一节。


## 2.2 层次性数据和闭包性质
序对，提供了一种用于构造复合数据的基本能力。
可以建立元素本身也是序对的序对，这是表结构得以作为一种表示工具的根本基础。这种能力称为cons的闭包性质。
某种组合数据对象的操作满足闭包性质，通过它组合起来数据对象得到的结果本身还可以通过同样的操作再进行组合。
闭包性质是任何一种组合功能的威力的关键要素。
它使我们可以建立层次性质的结构，这种结构由一些部分构成，而其中的各个部分又是由它们的部分构成，并且可以如此继续下去。

用序对来表示序列和树。

### 2.2.1 序列的表示
利用序对可以构造出序列--一批数据对象的一种有序汇集。

```lisp
(cons 1 
    (cons 2
        (cons 3 
            (cons 4 nil))))
```
通过嵌套的cons形成的一个序对的序列称为一个表。Scheme为方便表的构造，提供了一个基本操作list，上面的序列可以用(list 1 2 3 4)产生.
(list <a1> <a2> <a3> ... <an>) 
等价于
(cons <a1> (cons <a2> (cons ... (cons <an> nil) ...)))


```lisp
(define one-through-four (list 1 2 3 4))
one-through-four
```

可以通过car获取第一项，cdr获取除去第一项之后剩下的所有项形成的子表。
nil的值表示序列对的链结束，它可以当作一个不包含任何元素的序列，空表。

```js
//这里使用js，只是为了更好的理解书本中的意思
function list(){
    function listIter(items,count,i){
        if(i>count){
            return 'nil';
        }else{
            return cons(items[i],listIter(items,count,i+1));
        }
    }
    return listIter(arguments,arguments.length-1,0);
}
```


表操作
利用序对将元素的序列表示为表之后，可以使用常规的程序设计技术，通过顺序“向下cdr”表的方式完成对表的各种操作。

下面过程list-ref的实际参数是一个表和一个数n，它返回这个表中的第n个项。令表元素的编号从0开始。
计算list-ref的方法如下：
- 对n=0,list-ref应返回表的car
- 否则，list-ref返回表的cdr的第(n-1)个项

```lisp
(define (list-ref items n)
    (if(= n 0)
        (car items)
        (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))
(list-ref squares 3)
16


```

```js
function listRef(items,n){
    if(n==0){
        return car(items);
    }else{
        return listRef(cdr(items),n-1);
    }
}
```
// scheme包含一个基本操作null?用于检查参数是不是空表。返回表中项数的length

```
(define (length items)
（if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5))
(length odds)
3
```

```js
function length(items){
    if(isNull(items)){
        return 0;
    }else{
        return 1+length(cdr(items));
    }
}
```


- 任意一个表的length就是这个表的cdr的length加一
顺序地这样应用，直至达到了基础情况
- 空表的length是0
迭代计算方式来计算length

```
(define (length items)
    (define (length-iter a count)
        (if (null? a)
            count
            (length-iter (cdr a ) (+ 1 count))))
    (length-iter items 0))
```

```js
function length(items){
    function lengthIter(a,count){
        if(isNull(a)){
            return count;
        }else{
            return lengthIter(cddr(a),count+1);
        }
    }
    return lengthIter(items,0);
}
```

另一种程序设计技术，是在向下cdr一个表的过程中“向上cons”出一个结果表
过程append，它以两个表为参数，用它们的元素组合成一个新表：
```
(append squares odds)
(1 4 9 16 25 1 3 5)
(append odds squares)
(1 3 5 1 4 9 16 25)
```
append，要得到表list1和list2的append，按如下的方式做：
- 如果list1是空表，结果就是list2
- 否则应先做出list1的cdr和list2的append，而后将list1的car通过cons加到结果的前面
```
(define (append list1 list2))

```
### 对表的映射
一个特别有用的操作是将某种变换应用于一个表的所有元素，得到所有结果构成的表。
过程将一个表里的所有元素按给定因子做一次缩放：

```
(define (scale-list items factor)
    (if (null? items)
        nil
        (cons (* (car items) factor)
                (scale-list (cdr items) factor))))
(scale-list (list 1 2 3 4 5 6) 10)
(10 20 30 40 50 60)
```
可以将其中的公共模式表述为一个高阶过程，这一高阶过程称为map，它有一个过程参数和一个表参数，返回将这一过程应用于表中各个元素得到的结果形成的表。

```
(define (map proc items)
    (if (null? items)
        nil
        (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11 19))
(10 2.5 11 19)
(define (scale-list items factor)
    (map (lambda (x) (* x factor)) items))
```
map 建立起来处理表的高层抽象
通过使用map来定义scale-list抑制了细节层面上的情况，强调的是从元素表到结果表的一个缩放变换。
两种定义的方式的差异：
不在于计算机会执行不同的计算过程，而在于我们对这同一个过程的不同思考方式
从作用上看，map帮我们建立起了一层抽象屏障，将实现表变换的过程的实现，与如何提取表中元素以及组合结果的细节隔离开。
这种抽象提供了使我们有可能在保持从序列到序列的变换操作框架的同时，改变序列实现的低层细节。

练习 2.21

```
(define (squares-list items)
    (if (null? items)
        nil
        (cons (car items)  
                 (squares-list (cdr items)))))

(define (squares-list items)
    (map (lambda (x) (* x x)) items))
```

练习 2.22

//todo:代码之后再添加，先看书

### 2.2.2 层次性结构
将表做为序列的表示方式，可以推广到表示那些元素也是序列的序列。
((1 2) 3 4)
(cons (list 1 2) (list 3 4))

认识这种元素自身也是序列的序列的另一种方式，是把它们看作树
序列中的元素就是树的分支，那些本身也是序列的元素就形成了树中的子树

递归是处理树结构的一种很自然的工具。可以将对于树的操作归结为对它们的分支的操作，再将这种操作归结为分支的分支的操作。
直至达到了树的叶子。

//todo:树结构相关操作
count-leaves

对树的映射
map 是处理序列的一种强有力的抽象，map与递归的结合也是处理树的一种强有力抽象。
scale-tree

### 2.2.3序列作为一种约定的界面
强调数据抽象对复合数据的工作中起作用，借助这种思想，
可以设计出不会被数据表示的细节纠缠的程序，使程序能够保持很好的弹性，得以应用不同的具体表示上。

介绍与数据结构相关的另一种强有力的设计原理--使用约定的界面。
可以通过实现为高阶过程的程序抽象，抓住处理数值数据的一般程序模式。
要在复合数据上工作做出类似的操作，对数据结构的方式有很强的依赖性。
以一棵树为参数，计算出那些值为奇数的叶子的平方和：
//sum-odd-squares

构造出的是所有偶数的斐波契数fib(k)的一个表，其中的k小于等于某个给定整数n：
//even-fibs

上面两个过程在结构上差异非常大，但是对于两个计算的抽象描述却有极大的相似处。
第一个过程：
- 枚举出一棵树的树叶
- 过滤它们，选出其中的奇数
- 对选出的每一个数求平方
- 用+累积起得到的结果，从0开始

第二个过程：
- 枚举从0到n整数
- 对每个整数计算相应的斐波那契数
- 过滤它们，选出其中的偶数
- 用cons累积得到的结果，从空表开始

//信息处理工作
从一个枚举器开始，流过一个过滤器删除不满足条件的，通过映射对元素进行转换，累积器把所有元素重新组织起来。

这样的工作流，被分散到程序的各个部分，并且各部分也混在一起。
能够重新组织程序，使处理过程按照工作流进行，将会大大提高结果代码的清晰度。

序列操作
要更好组织程序使之能够清晰反应处理过程的结构，最关键的将注意力集中在处理过程中从一个步骤到下一个步骤的“信号”。
用一些表来表示这些信号，可以利用表操作实现每一个步骤的处理。
//todo:这里有个例子代码，后面补上

将程序表示为一些针对序列的操作，能帮助我们得到模块化的程序设计。得到由一些比较独立的片段的组合构成的设计。
通过提供一个标准部件的库，并使这些部件都有着一些能以各种灵活方式相互连接的约定界面，将能进一步推动人们去估模块化的设计。

在工程设计中，模块化结构是控制复杂性的一种威力强大的策略。
在真实的信号处理应用中，通常总是从标准化的过滤器和变换装置族中选出一些东西，通过级联的方式构造出各种系统。
序列操作也形成可以混合和匹配使用的标准的程序元素库。

用表实现的序列被作为一种方便的界面，可以利用这种界面去组合起各种处理模块。
如果以序列作为所用的统一表示结构，我们就能将程序对于数据结构的依赖性局限到不多的几个序列操作上。
通过修改这些操作，就可以在序列的不同表示之间转换，并保持程序的整个设计不变。

嵌套映射

可以扩充序列范型，将许多通常用嵌套循环表述的计算也包含进来。
问题：给定了自然数n，找了所有不同的有序对i和j,其中1<=j<i<=n，使得i+j是素数。
例如：假定n是6,满足条件的序对就是：
i       |  2  3  4  4  5  6  6
j       |  1  2  1   3  2  1  5
---------------------------
i+j    |  3  5  5  7  7  7  11

完成这一计算的一种很自然的组织方式：
- 首先生成出所有小于等于n的正自然数的有序对
- 而后通过过滤，得到那些和为素数的有序对
- 最后对每个通过了过滤的序对(i,j),产生出一个三元组(i,j,i+j)

生成有序对的序列的一种方式：
对每个整数i<=n，枚举出所有的整数j<i，并对每一对i和j生成序对(i,j)。

序列操作的方式说，要对序列(enumerate-interval 1 n)做一映射。
对于这个序列中里的每个i，都要对序列(enumerate-interval 1 (- i 1))做映射。
对于后一个序列中的每个j，我们要生成序对(list i j)。
这样就对每个i得到一个序对的序列。
将针对所有i的序列组合到一起，就产生出所需的序对序列。

//todo:这里代码需后期补上

### 2.2.4 实例：一个图形语言
介绍一种用于画图形的简单语言，以展示数据抽象和闭包的威力，其中也以一种很本质的方式使用了高阶过程。

图形语言

描述一种语言时，应该将注意力集中到语言的基本原语、它的组合手段以及它的抽象手段。

语言中只有一种元素，称为画家。
一个画家将画出一个图像，这种图像可以变形或者改变大小，以便能正好放到某个指定的平等四边形框架里。

举例：有一个称为wave的基本画家，它能做出折线画，而所做出图画的实际形状依赖于具体的框架。

有些画家可以图照片，称为rogers的基本画家。

为了组合起有关的图像，用一些可以给定画家构造出新画家的操作。
例如：
操作beside从两个画家出发，产生一个复合画家，它将第一个画家的图像画在框架中左边的一半里，将第二个画家的图像画在框架的右边一半里。
below从两个画家出发产生一个组合型画家，将第一个画家的图像画在第二个画家的图像之下。

有些操作将一个画家转换为另一个新画家。
例如：
flip-vert从一个画家出发，产生一个将该画家所画图像上下颠倒画出的画家
flip-horiz产生的画家将原画家的图像左右反转后画出。

在按这种方法构造复杂的图像时，利用了一个事实：
画家有关的语言的组合方式下是封闭的：
两个画家的beside或者below还是画家，还可以用它们作为元素去构造更复杂的画家。
就像用cons构造起各种表结构一样，所用的数据在组合方式下的闭包性质非常重要，这使我们能用不多几个操作构造出各种复杂的结构。

希望能抽象出典型的画家组合模式，以便将这种组合操作实现为一些过程。
这意味着我们并不需要这种图形语言里包含任何特殊的抽象机制，组合的方式是采用普通的过程。
对于画家，自动有了能够做原来可以对过程做的所有事情。


//todo 一些代码

可以定义一些递归操作

```js
function rightSplit(painter,n){
    if(n==0){
        return painter;
    }else{
        var smaller=rightSplit(painter,n-1);
        return beside(painter,below(smaller,smaller))
    }
}

function cornerSplit(painter,n){
    if(n==0){
        return painter;
    }else{
        var up=upSplit(painter,n-1);
        var right=rightSplit(painter,n-1);
        var topLeft=beside(up,up);
        var bottomRight=below(right,right);
        var corner=cornerSplit(painter,n-1);
        return beside(below(painter,topLeft),below(bottomRight,corner));
    }
}

function squaresLimit(painter,n){
    var quarter=cornerSplit(painter,n)
    var half=beside(flipHoriz(quarter),quarter);
    return below(flipVert(half),half);
}
```
练习 2.44
//upSplit代码

高阶操作
除了组合画家的抽象模式外，可以在高阶上工作，抽象出画家的各种组合操作的模式。
可以把画家操作看成是操控和描写这些元素的组合方法的元素--写出一些过程，它们以画家操作作为参数，创建出各种新的画家操作。

flipped-pairs、square-limit两者都将一个画家的四个拷贝安排在一个正方形的模式中，它们之间的差异仅仅在这些拷贝的旋转角度。

抽象出这种画家组合模式的一种方式是定义，基于四个单参数的画家操作，产生出一个画家操作，这一操作里将用这四个操作去变换一个给定的画家，
并将得到的结果放入一个正方形里。
tl、tr、bl、br，分别是应用于左上角，右上角，左下角，右下角的四个拷贝的变换：

```js
function squareOfFour(tl,tr,bl,br){
    return function(painter){
        var top=beside(tl(painter),tr(painter));
        var bottom=beside(bl(painter),br(painter));
        return below(bottom,top);
    }
}
function flipperPairs(painter){
    var combine4=squareOfFour(identity,flipVert,identity,flipVert);
    return combine4(painter);
}
function squaresLimit(painter,n){
    var combine4=squareOfFour(flipHoriz,identity,rotate180,flipVert);
    return combine4(corner(painter,n));
}
```
练习 2.45
//split代码
function rightSplit(painter,n){
    var com=split(beside,below);
    if(n==0)return painter;
    return com(painter,rightSplit(painter,n-1))
}

框架（图像的外框）
一个框架可以用三个向量描述：
一个基准向量和两个角向量。
基准向量：描述的是框架基准点相对于平面上某个绝对基准点的偏移量
角向量：描述了框架的角相对于框架基准点的偏移量

如果两个角向量正交，这个框架就是一个矩形。否则它就是一个一般的平行四边形。

根据数据对象的抽象原理，不用说清楚框架的具体表示方式，而只需要说明，存在着一个构造函数makeFrame，它能从三个向量出发做出一个框架。
与之对应的选择函数是originFrame,edge1Frame,edge2Frame。

用单位正方形(0<=x,y<=1)里的坐标去描述图像。
对于每个框架，我们要为它关联一个框架坐标映射，借助它完成有关图像的位移和伸缩，使之能够适配于这个框架。
这一映射的功能就是把单位正方形变换到相应框架，所采用的方法就是将向量v=(x,y)映射到下面的向量和：
orign(frame)+x*edge1(frame)+y*edge2(frame)

例如：
点(0,0)将被映射到给定框架的原点，(1,1)被映射到与原点对角的那个点，而(0.5,0.5)被映射到给定框架的中心点。
可以通过下面过程建立起框架的坐标映射：

```js
function frameCoordMap(frame){
    return function(v){
        return addVect(originFrame(frame),addVect(scaleVect(xcorVect(v),edge1Frame(frame)),scaleVect(ycorVect(v),edge2Frame(frame))));
    }
}

frameCoordMap(aFrame)(makeVect(0,0));
```

练习 2.46 
makeVect
xcorVect
ycorVect

addVect
subVect
scaleVect

练习 2.47

画家
一个画家被表示为一个过程，以框架作为实际参数，可以通过适当的位移和伸缩，画出一幅与这个框架匹配的图像。
如果p是一个画家而f是一个框架，通过以f作为实际参数调用p，就能产生出f中p的图像。

基本画家的实现细节依赖于特定图形系统的各种特性和被画图像的种类。
假定现在有一个过程drawLine，它能在屏幕上两个给定点之间画出一条直线，那么我们就可以利用它创建一个画折线图的画家。

```js
function segmentsPainter(segmentList){
    return function(frame){
        for(var i=0,len=segmentList.length;i<len;i++){
            var segment=segmentsPainter[i];
            var p1=frameCoordMap(frame)(startSegment(segment));
            var p2=frameCoordMap(frame)(endSegment(segment));
            drawLine(p1,p2);
        }
    }
}
```

将画家表示为过程，在这一图形语言中坚立起一道强有力的抽象屏障。
使我们可以创建和混用基于各种图形能力的各种类型的基本画家。
任何过程只要能取一个框架作为参数，画出某些可以伸缩后适合这个框架的东西，它就可以作为一个画家。

练习 2.48

练习 2.49

画家的变换和组合
各种对画家的操作的功能就是创建另一个画家，这里涉及到原来的画家，以及根据参数框架派生出的某些框架。
例如：
flipVert在反转画家时完全不必知道它们究竟如何工作，只需要知道怎样将一个框架上下颠倒就好了。产生出的画家使用的仍是原画家，只不过它在一个颠倒的框架里工作。

画家的操作都基于transformPainter，它以一个画家以及有关怎样变换框架和生成画家的信息作为参数。
对一个框架调用这样的变换去产生画家，实际完成的是对这个框架的一个变换，并基于变换后的框架去调用原来的画家。
transformPainter的参数是一些点（用向量表示），它们描述了新框架的各个角。
用于做框架变换时，
第一个参数描述的是新框架的原点
别外两个点描述的是新框架的两个边向量的终点。
这样，位于单位正方形里的参数描述的就是一个包含在原框架里面的框架。

```js
function transformPainter(painter,origin,corner1,corner2){
    return function(frame){
        var m=frameCoordMap(frame);
        var newOrigin=m(origin);
        return painter(makeFrame(newOrigin,subVect(m(corner1),newOrigin),subVect(m(corner2),newOrigin)));
    }
}
//垂直反转
function flipVert(painter){
    return transformPainter(painter,makeVect(0,1),makeVect(1,1),makeVect(0,0));
}
//
function shrinkToUpperRight(painter){
    return transformPainter(painter,makeVect(0.5,0.5),makeVect(1,0.5),makeVect(0.5,1));
}
//
function rotate90(painter){
    return transformPainter(painter,makeVect(1,0),makeVect(1,1),makeVect(0,0))
}
//
function squashInwards(painter){
    return transformPainter(painter,makeVect(0.35,0.35),makeVect(0.65,0.35),makeVect(0.35,0.65));
}

```

画家的数据抽象，特别是将画家用过程表示，怎样使beside的实现变得如此简单。
这里的beside完全不必了解作为其成分的各个画家的任何东西，它只需要知道这些画家能够在指定框架里画出一些东西就够了。


强健设计的语言层次
前面介绍的有关过程和数据抽象的关键思想，得到演示。

基本数据抽象和画家都用过程表示实现，使语言能以一种统一方式去处理各种本质上完全不同的画图能力。
实现组合的方法也满足闭包性质，使我们可以轻易构造起各种复杂的设计。
用于做过程抽象的所有工具，都可用作组合画家抽象手段。

对程序设计的另一个关键概念，分层设计。一个复杂的系统应该通过一系列的层次构造出来，为了描述这些层次，需要使用一系列的语言。
构造各个层次的方式，就是设法组合起来人作为这一层次中部件的各种基本元素，而这样构造出来的部件又可以作为另一个层次里的基本元素。
在分层设计中，每个层次上所用的语言都提供了一些基本元素、组合手段，还有对层次中的适当细节做抽象的手段。

在复杂系统的工程中广泛使用这种分层设计方法。
例如：在计算机工程里，电阻和晶体管被组合起来（用模拟电路的语言），产生了一些部件，例如与门、或门等等。
这些门电路又被作为数字电路设计的语言中的基本元素。
将这类部件组合起来，构成了处理器、总线和存储系统又通过它们的组合构造出各种计算机，此时采用的是适合于计算机体系结构的语言。

分层设计有助于使程序更加强健，使我们在给定规范发生一些小变时，只需要修改少量的代码。

分层结构中的每个层次都为表述系统的特征提供一套独特词汇，以及一套修改这一系统的方式。

练习 2.52


## 2.3 符号数据
使用过的所有复合数据，都是从数值出发构造起来的。
扩充语言的表述能力，引进任意符号作为数据的功能。

### 2.3.1 引号
如果能构造出采用符号的复合数据。

(a b c d)
(23 45 17)

这些包含着符号的表看起来就像我我们语言里的表达式

(* (+ 23 45) (+ x 9))
(define (fact n) (if (= n 1) 1 (* n (fact (- n 1)))))

为了能操作这些符号，语言里就需要一种新元素：为数据对象加引号的能力。
如果我们希望构造(a b)，不能用(list a b)完成，因为这一表达式将要构造出的是a和b的值的表，而不是这两个符号本身的表。

将表和符号标记为应该人作为数据对象看待，而不是作为应该求值的表达式。这里可以使用引号。

//todo 这里欠了很多代码
练习 2.53
练习 2.54
练习 2.55

### 实例：符号求导
进一步阐述数据抽象的思想
设计一个执行代数表达式的符号求导的过程。

希望该过程以一个代数表达式和一个变量作为参数，返回这个表达式相对于该变量的导数。
如，如果送给这个过程的参数是ax^2+bx+c和x，它应该返回2ax+b。
符号求导数对于Lisp有着特殊的意义，它正是推动人们去为符号操作开发计算机语言的重要实例之一。
人们为符号数学工作开发强有力系统的研究领域的开端。

为开发出一个符号计算程序，像开发有理数系统那样，采用同样的数据抽象策略。

首先，定义一个求导算法，令它在一些抽象对象上操作。例如“和”、“乘积”和“变量”，并不考虑这些对象实际上如何表示，后面才关心具体表示的问题。

对抽象数据的求导程序

先考虑一个简单的符号求导程序，它处理的表达式都是由对于两个参数的加和乘运算构造起来的。

dc/dx=0
dx/dx=1
d(u+v)/dx=du/dx+dv/dx
d(uv)/dx=u(dv/dx)+v(du/dx)

最后两条规则具有递归的性质。
要想得到一个和式的导数，
首先，要找出其中各个项的导数，而后将它们相加。
这里的每个项又可能是需要进一步分解的表达式。
通过这种分解，得到越来越小的片段，最终将产生出常量或者变量，它们的导数就是0或1;

有一种表示代数表达式的方式，一定能判断出某个表达式是否是一个和式、乘式、常量或变量，提取出表达式里的各个部分。

对于一个和式，希望取得其被加项和加项。
能从几个部分出发构造出整个表达式。

假定实现已经有了一些过程，它们实现下面的构造函数、选择函数和谓词：

```
(variable? e)                  //e是变量吗？
(same-variable? v1 v2)   //v1和v2是同一个变量吗？
(sum? e)                      //e是和式吗？
(addend e)                   //e的被加数
(augend e)                   //e的加数
(make-sum a1 a2)         //构造起a1和a2的和式

(product? p)                 //e是乘式吗？
(multiplier e)                 //e的被乘数
(multiplicand e)             //e的乘数
(make-product m1 m2)  //构造起m1和m2的乘式
```

利用这些过程，以及判断表达式是否数值的基本过程number?，就可以将各种求导规则表达出来

```
(define (deriv exp var)
   (cond ((numer? exp) 0)
            ((variable? exp)
             (if (same-variable? exp var) 1 0))
            ((sum? exp)
             (make-sum (deriv (addend exp) var)
                             (deriv (augend exp) var)))
            ((product? exp)
             (make-sum 
                 (make-product (multiplier exp)
                                       (deriv (multiplicand exp) var))
                 (make-product (deriv (multiplier exp) var)
                                       (multiplicand exp))))
            (else
              (error "unknow expression type -- DERIV " exp))))
```

deriv里包含了一个完整的求导算法。
它是基于抽象数据表述的，因此，无论如何选择代数表达式的具体表示，只要设计了一组正确的选择函数和构造函数，
这个过程都可以工作。表示的问题是下面必须考虑的问题。

代数表达式的表示
我们可以设想出用表结构表示代数表达式的方法。
例如，可以利用符号的表直接反应代数的记法形式，将表达式ax+b表示为表（a * x + b）。
一种更直接了当的选择，是采用lisp里面表示组合式的那种带括号的前缀形式。
将ax+b表示为（+ （* a x）b）。

有关求导的问题就是：
- 变量就是符号，它们可以用基本谓词symbol?判断：
(define (variable? x) (symbol? x))

- 两个变量相同就是表示它们的符号相互eq?:
(define (same-variable? v1 v2) 
          (and (variable? v1) (variable? v2) (eq? v1 v2)))

- 和式与乘式都构造为表：
(define (make-sum a1 a2) (list + a1 a2))
(define (make-product m1 m2) (list * m1 m2))

- 和式就是第一个元素为符号+的表
(define (sum? x) 
        (and (pair? x) (eq? (car x) '+)))

- 被加数是表示和式的表里的第二个元素
(define (addend s) (cadr s))

- 加数是表示和式的表里的第三个元素
(define (addend s) (caddr s))

- 乘式就是第一个元素为符号*的表：

(define (product? x) 
        (and (pair? x) (eq? (car x) '*)))

- 被乘数是表示乘式的表里的第二个元素
(define (multiplier p) (cadr p))

- 乘数是表示乘式的表里的第三个元素
(define (multiplicand p) (caddr p))

只需要把这些过程与deriv放在一起。

(deriv '(+ x 3) 'x)
(+ 1 0)

(deriv '(* x y) 'x)
(+ (* x 0) (* 1 y))


希望结果化简到最简单的形式

有理数的化简，只需要修改构造函数和选择函数的实现。

采用同样的策略。
不必修改deriv，只需要修改make-sum，使得当两个求和对象都是数时，make-sum求出它们的和返回。
如果一个求和对象是0,那么make-sum就是直接返回另一个对象。

```
(define (make-sum a1 a2) 
     (cond ((=number? a1 0) a2)
              ((=number? a2 0) a1)
              ((and (number? a1) (number? a2)) (+ a1 a2))
              (else (list '+ a1 a2))))

(define (=number? exp num) 
          (and (number? exp) (= exp num)))
```
与此类似，修改make-product，设法引进下面的规则：0与任何东西的乘积都是0,1与任何东西的乘积都是那个东西：

```
(define (make-product m1 m2) 
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
             ((=number? m1 1) m2)
             ((=number? m2 1) m1)
             ((and (number? m1) (number? m2)) (* m1 m2))))


(deriv '(+ x 3) 'x)
1

(deriv '(* x y) 'x)
y
```

代数简化是一个非常复杂的问题，除了其他各种因素，一个重要的问题：对于某种用途的最简形式，对于另一种用途可能就不是最简形式。

练习 2.56
练习 2.57
练习 2.58

### 2.3.3 实例：集合的表示
构造出两个复合数据对象的表示：有理数和代数表达式。
都采用了某一种选择，在构造时或选择成员时去简化（约简）有关的表示。
选择用表的形式表示这些结构。

一个集合就是一些不同对象的汇集。
利用数据抽象的方法，使用一组可以作用于“集合”的操作来定义它们。

union-set
intersection-set
element-of-set？
adjoin-set

其中 
element-of-set？是一个谓词，用于确定某个给定元素是不是某个给定集合的成员。
adjoin-set 以一个对象和一个集合对象为参数，返回一个集合，其中包含了原集合的所有元素，再加上刚刚加入进来的新元素。
union-set 计算出两个集合的并集，其中包含了所有属于两个集合之一的元素。
intersection-set 计算出两个集合的交信，包含着同时出现在两个集合的元素。
从数据抽象的观点看，在设计有关的表示方面具有充分的自由，只要在这种表示上实现的上述操作能以某种方式符合上面给出的解释。

集合作为未排序的表

集合的一种表示方式是用其元素的表，其中任何元素的出现都不能超过一次。
空集就是空表来表示。

```
// element-of-set
(define (element-of-set? x set)
    (cond ((null? set) false)
             ((equal? x (car set)) true)
             (else (element-of-set? x (cdr set)))))

//adjoin-set
(define (adjoin-set x set)
    (if (element-of-set? x set) set (cons x set)))

//intersection-set 
(define (intersection-set set1 set2) 
        (cond ((or (null? set1) (null? set2)) '())
                 ((element-of-set? (car set1) set2)
                  (cons (car set1) (intersection-set (cdr set1) set2)))
                 (else (intersection-set (cdr set1) set2))))


```

在设计一种表示形式时，必须关注的事情是效率问题。
上面定义的集合操作的工作步数。
都使用了element-of-set?，这个操作的速度对整个集合的实现效率有重大影响。
如果集合中有n个元素，element-of-set?就可以需要n步才能完成。以O(n)的速度增长。
adjoin-set使用这个操作，在两个集合大小都为n时，需要O(n^2)。union-set的情况相同。

练习 2.59
练习 2.60

集合作为排序的表

加速集合操作的一种方式是改变表示方式，使集合元素在表中按照上升排列。
需要有某种方式来比较两个元素，以便确定哪个元素更大一些。
可以按字典序做符号的比较
同意采用某种方式为每个对象关联一个唯一的数，在比较元素的时候就比较与之对应的数。

这里只讨论集合元素为数值的情况。
可以直接使用<和>做元素的比较。

下面将数的集合表示为元素按照上升顺序排列的表
第一种方式下，集合{1,3,6,10}的元素在相应表里可以任意排列
在新的表示方式中，只允许表(1 3 6 10)

从操作element-of-set?可以看出新表示方式的优势：
为了检查一个项的存在性，现在不用扫描整个表。
如果检查中遇到的某个元素大于当时要找的东西，就可以断定这个东西根本不在表里：

```
(define (element-of-set? x set)
    (cond ((null? set) false)
             ((= x (car set)) true)
             ((< x (car set)) false)
             (else (element-of-set? x (cdr set)))))
```
最坏的情况和未排序的情况所用的步数相同。
排除了不在集合中的情况。

练习 2.61
练习 2.62

集合作为二叉树
将集合元素安排成一棵树的形式，可以得到比排序表示更好的结果
树中每个结点保存集合中的一个元素，称为该结点的“数据项”，它还链接到另外的两个结点（可能为空）。
其中“左边”的链接所指向的所有元素均小于本结点的元素，而“右边”链接到的元素都大于本结点里的元素。
同一个集合表示为树可以有多种不同的方式，对于合法的要求就是，位于左子树里的所有元素都小于本结点里的数据项，而位于右子树里的所有元素都大于它。

树表示方法的优点在于：
假定我们希望检查某个数x是否在一个集合里，那么就可以用x和树顶结点的数据项相比较。
如果x小于它，就可以只搜索左子树，如果x比它大，那么只搜索右子树。

这样做时，如果该树是“平衡的”，也就是每棵子树大约是整个树的一半大，那么搜索规模为n的树的问题，归约为搜索规模的n/2的树的问题。
由于经过每个步骤能够使树的大小减少一半，规模为n的树的计算步数以 O(log n)速度增长。
在规模很大时，相对于原来的表示，现在的速度明显快很多。

用表来表示树，将结点表示为三个元素的表：本结点中的数据项，其左子树和右子树。
以空表作为左子树或者右子树，就表示没有子树连接在那里。

```
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right) 
    (list entry left right))



(define (element-of-set? x set) 
    (cond ((null? set) false)
             ((= x (entry set)) true)
             ((< x (entry set))
              (element-of-set? x (left-branch set)))
             ((> x (entry set))
              (element-of-set? x (right-branch set)))))

```

向集合里加入一个项的实现也需要 O(log n)。
为了加入元素x，我们需要将x与结点数据项比较，以便确定x应该加入右子树还是左子树中。
在将x加入适当的分支之后，将新构造出的这个分支、原来的数据项与另一分支放到一起。
如果x等于这个数据项，那么直接返回这个结点。
如果需要将x加入一个空子树，那么就生成一棵树，以x作为数据项，并让它具有空的左右分支。

```
(define (adjoin-set x set)
    (cond ((null? set) (make-tree x '() '()))
             ((= x (entry set)) set)
             ((< x (entry set)) 
              (make-tree (entry set) 
                               (adjoin-set x (left-branch set))
                               (right-branch set)))
            ((> x (entry set))
             (make-tree (entry set)
                              (left-branch set)
                              (adjoin-set x (right-branch set))))))
```

练习 2.63
练习 2.64
练习 2.65

集合与信息检索

用表表示集合的各种选择，并看到了数据对象表示的选择可能如何深刻地影响到使用数据的程序的性能。

关注集合的另一个原因，在涉及信息检索的各种应用中将会一次又一次地出现。

考虑一个包含大量独立记录的数据库，例如，一个企业中的人事文件，或一个会计系统里的交易记录。
典型的数据管理系统都需要将大量时间用在访问和修改所存的数据上，因此就需要访问记录的高效方法。

完成此事的一种方式是将每个记录中的一部分当作标识key（键值）。
所用的键值可以是任何能唯一标识记录的东西。
对于人事文件而言，可能是雇员的id编码。
对于会计系统而言，可能是交易编号。

在确定了采用了什么键值之后，就可以将记录定义为一种数据结构，并包含key选择过程，它可以从给定记录中提取出有关的数值。

现在就可以将这个数据库表示为一个记录的集合。
为了根据给定键值确定相关记录的位置，用过程lookup，它以一个键值和一个数据库为参数，返回具有这个键值的记录，
或在找不到相应记录时报告失败。

```
(define (lookup give-key set-of-records) 
    (cond ((null? set-of-records) false)
             ((equal? give-key (key (car set-of-records)))
              (car set-of-records))
            (else (lookup give-key (cdr set-of-records)))))
```

比未排序表更好的表示大集合的方法。

常常需要“随机访问”其中记录的信息检索系统通常用某种基于树的方法实现。
例如：二叉树。
在设计这种系统时，数据抽象的方法学将很有帮助。
设计师可以创建简单而直接的初始实现，例如采用未排序的表。
对于最终的系统而言，这样并不合适，但采用这种方式提供一个demo的数据库，
对用于测试系统的其他部分则有帮助。
然后可以将数据表示修改得更加精细。

如果对数据库的访问都是基于抽象的选择函数和构造函数，这样的表示的改变就不会要求对系统其余部分做任何修改。

练习 2.66

### 2.3.4 实例：Huffman编码
实际使用表结构和数据抽象去操作集合与树的例子。
想确定一些用0和1的序列表示数据的方法。

用于在计算机里表示文本的ascii标准编码将每个字符表示为一个包含7个二进制位的序列，采用7个二进制位能够区分2^7种不同情况，即128个可能不同的字符。

一般，如果我们需要区分n个不同字符，那么就需要为每个字符使用log n 个二进制位。

假设我们的所有信息都是用A,B,C,D,E,F,G和H这样8个字符构成的，那么就可以选择每个字符用3个二进制位，例如：
A  000
B  001
C  010
D  011
E  100
F   101
G  110
H  111
消息
bacadaeafabbaaagah
将编码为54个二进制位
001000010000010000100000100000101000001001000000000110000111
ascii码和上面a到h编码这样的编码方式称为定长编码，它们采用了同样数目的二进制位表示消息中的每个字符。
变长编码方式就是用不同数目的二进制位表示不同的字符，这种方式有时也可能有些优势。

莫尔斯电报码对于字母表中各个字母就没有用同样数目的点和划，特别常见的字母e只用一个点。
一般较常见的用较短的码，这样可以更有效地完成数据的编码。
A 0
B 100
C 1010
D 1011
E 1100
F 1101
G 1110
H 1111
上面的消息将编写为如下的串
1000010100101101100011010100100000111001111

这样的方式只包含42个字符

采用定长编码有一个困难，就是在读0/1序列的过程中确定何时到达了一个字符的结束。

莫尔斯码解决这一问题的方式是在每个字母点划序列之后用一个特殊的分隔符（用了一个间歇）

另一种解决方式是以某种方式设计编码称为前缀码。
上面例子里,A编码0,B编码为100，没有其他字符的编码由0或者100开始。

如果能用变长前缀码去利用被编码消息中符号出现的相对频度，那么就能有明显地节约空间。

完成这件事情的一种特定方式称为Huffman编码，
一个Huffman编码可以表示为一棵二叉树，
其中的树叶是被编码的符号。
每个非结点代表一个集合，其中包含了这一结点之下的所有树叶上的符号。
位于树叶的每个符号还被赋予一个权重（相对频度），
非叶结点所包含的权重是位于它之下的所有叶结点的权重之和。
这种权重在编码和解码中并不使用。在构造树的过程中需要它们的帮助。

给定了一棵Huffman树，要找出任一符号的编码，只需要从树根开始向下运动，直到到达了保存着这一符号的树叶为止，
在每次向左行时就给代码加上一个0,右行时加上一个1。
在确定向哪个分支运行时，需要检查该分支是否包含着与这一符号对应的叶结点，或其集合中包含着这个符号。

在用Huffman树做一个序列的解码时，也从树根开始，通过序列中的0或1确定是移向左分支还是右分支。
每当我们到达一个叶结点时，就生成出了消息中的一个符号。此时就重新从树根开始去确定下一个符号。

生成Huffman树
给定了符号的“字母表”和它们的相对频度，怎么才能构造出“最好的”编码呢？
哪样的树能使消息编码的位数达到最少？
Huffman给出了完成这件事的一个算法，并且证明了，
对于符号所出现的相对频度与构造树的消息相符的消息而言，这样产生出的编码确实是最好的变长编码。

生成Huffman树的算法实际上十分简单，其想法就是设法安排这棵树，使得那些带有最低频度的符号出现在离树根最远的地方。
这一构造过程从叶结点的集合开始，这种结点中包含各个符号和它们的频度，这就是开始构造编码的初始数据。
现在要找了两个具有最低权重的叶，并归并它们，产生出一个以这两个结点为左右分支的结点，并用这一新结点代替它们。
随后继续这一过程，在其中的每一步都归并两个具有最小权重的结点，将它们从集合中删除，并用一个以这两个结点作为左右分支的新结点取而代之。
当集合中只剩下一个结点时，这一过程终止，而这个结点就是树根。

这一算法并不能描述一棵唯一的树，这是因为，每步选出的最小权重结点有可以不唯一。
做归并时，两个结点的顺序也是任意的，也就是说，随便哪个都可以做为左分支或右分支。

Huffman树的表示
做一个使用Huffman树完成消息编码和解码，并能根据上面给出的梗概生成Huffman树的系统。
将一棵树的树叶表示为包含符号leaf、叶中符号和权重的表：

```
(define (make-leaf symbol weight)
        (list 'leaf symbol weight))

(define (leaf? object)
    (eq? (car object) 'leaf)

(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
```
一棵一般的树也是一个表，其中包含一个左分支，一个右分支，一个符号集和一个权重。
符号集合就是符号的表，这里没有用更复杂的集合表示。
在归并两个结点做出一棵树时，树的权重也是这两个结点的权重之和，其符号集就是两个结点的符号集的并集。

```
(define (make-code-tree left right)
    (list left
          right 
          (append (symbols left) (symbols right))
          (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))

(define (symbols tree)
    (if (leaf? tree)
        (list (symbol-left tree))
        (caddr tree)))

(define (weight tree)
    (if (leaf? tree)
        (weight-leaf tree)
        (caddr tree)))

```
在对树叶或一般树调用过程symbols和weight时，它们需要做的事情有一点不同。
这些不过是通用型过程的简单实例。

解码过程
解码算法，它以一个0/1的表和一棵Huffman树为参数：

```
(define (decode bits tree) 
    (define (decode-l bits current-branch)
        (if (null? bits)
            '()
            (let ((next-branch
                   (choose-branch (car bits) current-branch)))
                (if (leaf? next-branch)
                    (cons (symbol-leaf next-branch) 
                            (decode-l (cdr bits) tree))
                    (decode-l (cdr bits) next-branch)))))
     (decode-l bits tree))

(define (choose-branch bit branch)
    (cond ((= bit 0) (left-branch branch))
             ((= bit 1) (right-branch branch))
             (else (error "bad bit -- CHOOSE-BRANCH" bit))))

```

decode-l 有两个参数，bits是包含二进制位的表，current-branch是树中的当前位置。
它不断在树里“向下”移动，根据表中下一个位是0或1选择树的左分支或右分支。
一旦到达了叶结点，它就把位于这里的符号作为消息中的下一个符号，将其cons到对于消息里随后部分的解码结果之前。
而后这一解码又从树根重新开始。

带权重元素的集合
树表示里，每个非叶结点包含着一个符号符合，在这里表示为一个简单的表。
上面的树生成算法要求能对树叶和树的集合工作，以便不断地归并一对一对的最小项。
因为这里要反复去确定集合里的最小项，采用某种有序的集合表示会更方便。

先将树叶和树的集合表示为一个按照权重上升顺序排列的表。

```
(define (adjoin-set x set)
    (cond ((null? set) (list x))
             ((< (weight x) (weight (car set)) (cons x set)))
             (else (cons (car set)
                             (adjoin-set x (cdr set))))))

```
一过程以符号-权重对偶的表为参数，例如
((A 4) (B 2) (C 1) (D 1)),它构造出树叶的初始排序集合，以便Huffman算法能够去归并：

```
(define (make-leaf-set pairs)
    (if (null? pairs)
        '()
        (let ((pair (car pairs)))
            (adjoin-set (make-leaf (car pair)
                                             (cadr pair))
                             (make-leaf-set (cdr pairs))))))
```

//todo 练习先不进行，上面的代码改写成js后再进行
练习 2.67
练习 2.68
练习 2.69
练习 2.70
练习 2.71
练习 2.72

## 2.4 抽象数据的多重表示
数据抽象是一种构造系统的方法学，采用这种方法，将使一个程序中的大部分描述能与这一程序所操作的数据对象的具体表示的选择无关。
前面将一个使用有理数的程序的设计与有理数的实现工作相互分离，具体实现中采用的是计算机语言所提供的构造复合数据的基本机制。
这里的关键性思想是构筑起一道抽象屏障，也把执行有理数算术的过程与使用有理数的“高层”过程隔离开。

数据抽象屏障是控制复杂性的强有力工具。
通过对数据对象基础表示的屏蔽，可以将设计一个大程序的任务，分割为一组可以分别处理的较小任务。
这种类型的数据抽象还不够强大有力，这里说数据对象的“基础表示”并不一定总有意义。

对一个数据对象可能存在多种有用的表示方式，而我们希望设计出的系统能处理多种表示方式。
例如：复数就可以表示为两种几乎等价的形式：直角坐标形式（实部和虚部）和极坐标形式（模和幅角）。
有时采用直角坐标形式更合适，有时极坐标形式更方便。

设想一个系统，其中复数同时采用了两种表示方式，而其中的过程可以对具有任意表示形式的复数工作。

一个系统的程序设计常常是由许多人通过一个相当长时期的工作完成的，
系统的需求也在随着时间而不断变化。这样一个环境，
要求每个人都在数据表示的选择上达成一致是根本不可能的事情。
所以除了需要将表示与使用隔离的数据抽象屏障之外，还需要有抽象屏障去隔离互不相同的设计选择，
以便允许不同的设计选择在同一个程序里共存。
进一步说，由于大型程序常常是通过组合起一些现存模块构造起来的，而这些模块又都是独立设计的，
需要一些方法，使程序可能逐步地将许多模块结合成一个大型的系统，而不必重新设计或者重新实现这些模块。

##### 本节学习如何去处理数据，使它们可能在一个程序的不同部分中采用不同的表示方式。
需要去构造通用型过程--就是可以在不止一种数据表示上操作的过程。
构造通用型过程所采用的主要技术，是让它们在带有类型标志的数据对象上工作。
也就是让这些数据对象包含着它们应该如何处理的明确的信息。
要讨论数据导向的程序设计，这是一种用于构造采用了通用型操作的系统有力而且方便的技术。

我们从简单的复数实例开始，看看如何采用类型标志和数据导向的风格，为复数分别设计出直角坐标表示和极坐标表示，
而又维持一种抽象的“复数”数据对象的概念。

做到这一点的方式是定义基于通用型选择函数定义复数的算术运算（add-complex,sub-complex,mul-complex,div-complex）,
使这些选择函数能访问一个复数的各个部分，无论复数采用的是什么表示方式。
作为结果的复数系统。
其中包含两种不同类型的抽象屏障，
“水平”抽象屏障扮演的角色，是使我们将“高层”操作与“低层”表示隔离开。
“垂直”屏障，使我们能够隔离不同的设计，并且还能够安装其他的表示方式。

### 2.4.1 复数的表示
开发一个完成复数算术运算的系统，作为使用通用型操作的程序的一个简单的例子。
先讨论一下复数表示的两种表示方式
坐标形式（实部和虚部）
将复数集合设想为一个带有两个坐标轴的两个维度，一个实轴一个虚轴。
那么复数z=x+iy（其中i^2=-1）可看作这个平面的一个点，其中的实坐标是x而虚坐标为y。
复数加法，就可以看成是两个坐标的相加。
实部(z1+z2)=实部(z1)+实部(z2)
虚部(z1+z2)=虚部(z1)+虚部(z2)

极坐标形式（模和幅角）
复数乘法，
模(z1*z2)=模(z1)*模(z2)
幅角(z1*z2)=幅角(z1)*幅角(z2)

可以发现，复数的两种不同表示方式，它们分别适合不同的运算。

从编写使用复数的程序的开发人员角度看，数据抽象原理的建议是所有复数操作都应该可以使用，无论计算机所用的具体表示形式是什么。

例如，我们也常常需要取得一个复数的模，即使它原本采用的是复数的直角坐标表示。反之也是。

假定所有复数计算的实现都基于如下四个选择函数：
real-part,imag-part,magnitude,angle；
还要假设有两个构造复数的过程：
make-from-real-imag 返回一个采用实部和虚部描述的复数
make-from-mag-ang 返回一个采用模和幅角描述的复数。

对于任何复数z，下面的运算都会返回z

(make-from-real-imag (real-part z) (imag-part z))
和
(make-from-mag-ang (magnitude z) (angle z))

利用这些构造函数和选择函数，可以实现复数算术，其中使用由这些构造函数和选择函数所刻画的“抽象数据”。

就像上面所描述的一样，复数的加法和减法采用实部和虚部的方式描述，乘法和除法采用模和幅度的方式描述。

```
(define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2)
                                     (+ (imag-part z1) (imag-part z2)))))

(define (add-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2)
                                    (- (imag-part z1) (imag-part z2)))))

(define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2)
                                     (* (angle z1) (angle z2)))))

(define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2)
                                     (/ (angle z1) (angle z2)))))

```

选择一种表示方式，而且必须基于基本的数值和基本表结构，基于它们实现各个构造函数和选择函数

需要两种方式来完成转换的工作：
可以将复数按“直角坐标形式”表示为一个有序对（实部，虚部）
按“极坐标形式”表示为有序对（模，幅角）。

首先，实现两种复数系统。
一种直角坐标形式
一种极坐标形式

直角坐标形式在实现获取模和幅度时，需要构造如下过程

```
(define (real-part z) (car z))
(define (imag-part z) (cdr z))
(define (magnitude z)
    (sqrt (+ (square (real-part z)) (square (imag-part z)))))
(define (angle z)
    (atan (imag-part z) (real-part z)))
(define (make-from-real-imag x y)
        (cons x y))
(define (make-from-mag-ang r a)
        (cons (* r (cos a)) (* r (sin a))))
```

极坐标的形式

```
(define (real-part z)
    (* (magnitude z) (cos (angle z))))

(define (imag-part z)
    (* (magnitude z) (sin (angle z))))

(define (magnitude z) (car z))
(define (angle z) (cdr z))

(define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
        (atan y x)))

(define (make-from-mag-ang r a) (cons r a))
```

### 2.4.2 带标志数据
认识数据抽象的一种方式是将其看作“最小允许原则”的一个应用。
上面两种复数实现的形式，由选择函数和构造函数形成的抽象屏障，使我们可以把为自己所用数据对象选择具体表示形式的事情尽量向后推，而且还能保持系统设计的最大灵活性。

最小允诺原则还可以推进到更极端的情况。
如果要一个系统中包含这两种不同表示形式，那么就需要一种方式，将极坐标形式的数据与直角坐标形式的数据区分开。否则调用函数无法知道最终的结果是否正确。
完成这种区分的一种方式，就是在每个复数里包含一个类型标志部分--用符号rectangular或者polar。
如果需要操作一个复数，借助这个标志就可以确定应该使用的选择函数了。

为了能对带标志数据进行各种操作，假定已经有过程type-tag和contents，它们分别从数据对象中提取出类型标志和实际内容(对于复数的情况，其中的极坐标或直角坐标)。

假定有一个过程attach-tag，它以一个标志和实际内容为参数，生成出一个带标志的数据对象。

实现这些的直接方式就是采用普通的表结构：

```
(define (attach-tag type-tag contents)
    (cons type-tag contents))

(define (type-tag datum)
    (if (pair? datum)
        (car datum)
        (error "bad tagged datum -- TYPE-TAG" datum)))

(define (contents datum)
    (if (pair? datum)
        (cdr datum)
        (error "bad tagged datum -- CONTENTS" datum)))
(define (rectangular? z)
    (eq? (type-tag z) 'rectangular))
(define (polar? z)
    (eq? (type-tag z) 'polar))

```
有了这个标志之后，再回去修改上面的代码，使两种不同的表示共存于同一系统中。

当构造一个复数时，总为它加上标志，说明采用的是直角坐标还是极坐标。

还必须保证两种形式使用的过程名不冲突。保证这一点就是在每种操作的过程后面都加上标识，作为后缀。
修改后的直角坐标表示：

```
(define (real-part-rectangular z) (car z))

(define (imag-part-rectangular z) (cdr z))

(define (magnitude-rectangular z)
    (sqrt (+ (square (real-part-rectangular z)) 
                (square (imag-part-rectangular z)))))

(define (angle-rectangular z)
    (atan (imag-part-rectangular z)
            (real-part-rectangular z)))

(define (make-from-real-imag-rectangular x y)
        (attach-tag 'rectangular (cons x y)))
(define (make-from-mag-ang-rectangular r a)
    (attach-tag 'rectangular 
                    (cons (* r (cos a)) (* r (sin a)))))

```

修改后的极坐标表示：

```
(define (real-part-polar z)
    (* (magnitude-polar z) (cos (angle-polar z))))

(define (imag-part-polar z)
    (* (magnitude-polar z) (sin (angle-polar z))))

(define (magnitude-polar z) (car z))

(define (angle-polar z) (cdr z))

(define (make-from-real-imag-polar x y)
    (attach-tag 'polar 
                    (cons (sqrt (+ (square x) (square y)))
                             (atan x y))))

(define (make-from-mag-ang-polar r a)
    (attach-tag 'polar (cons r a)))
```

每个通用型选择函数都需要实现为这样的过程，它首先检查参数的标志，而后去调用处理该类数据的适当过程。
使用contents提取原始无标志数据，并将它送给所需的直角坐标过程或极坐标过程：

```
(define (real-part z)
    (cond ((rectangular? z)
              (real-part-rectangular (contents z)))
             ((polar? z)
              (real-part-polar (contents z)))
             (else (error "unknow type -- REAL-PART" z))))

(define (imag-part z)
    (cond ((rectangular? z)
              (imag-part-rectangular (contents z)))
             ((polar? z)
              (imag-part-polar (contents z)))
             (else (error "unknow type -- IMAG-PART" z))))

(define (magnitude z)
    (cond ((rectangular? z)
              (magnitude-rectangular (contents z)))
             ((polar? z)
              (magnitude-polar (contents z)))
             (else (error "unknow type -- MAGNITUDE" z))))


(define (angle z)
    (cond ((rectangular? z)
              (angle-rectangular (contents z)))
             ((polar? z)
              (angle-polar (contents z)))
             (else (error "unknow type -- ANGLE" z))))
```

对于复数算术运算的操作，因为它们使用的是通用型的选择函数，对任何表示都能工作。

最后，选用哪种形式来表示构造函数。
一种合理的选择是，在用实部和虚部时采用直角坐标表示，有模和幅角时采用极坐标表示：

```
(define (make-from-real-imag x y)
    (make-from-real-imag-rectangular x y))

(define (make-from-mag-ang r a)
    (make-from-mag-ang-polar r a))

```

建立不同表示之间的界面的一般性机制：
在一种给定的表示实现中，复数是一种无类型的对偶。当通用型选择函数对一个polar类型的复数进行操作时，它会剥去标志并将相应内容传递给另一种形式的表示。
这种剥去和加上标志的规范方式可以成为一种重要的组织策略。

### 2.4.3 数据导向的程序设计和可加性

