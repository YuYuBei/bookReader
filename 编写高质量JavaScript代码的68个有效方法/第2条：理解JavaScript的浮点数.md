## JavaScript数值型类型只有数字

js只有一种数值型数据类型，不管是整数还是浮点数，js都把归为数字。

> typeof 17;   // “number”
> 
> typeof 98.6; // “number”
> 
> typeof –2.1; // “number”

js中的所有数字都是双精度浮点数。是由IEEE754标准制定的64位编码数字（这个是什么东东，不知道，回头查一下吧）

那么js是如何表达整数的，双精度浮点数可以完美地表示高达53位精度的整数（没有什么概念，没处理过多大的数据，没用完过！），从-9007199254740992（-2<sup>53</sup>）到9007199254740992（2<sup>53</sup>）的所有整数都是有效的双精度浮点数。

大多数算术运算符都可以使用整数、实数或两者的组合进行计算。

> 0.1*1.9    //0.19
> 
> -99+100  //1
> 
> 21-12.3  //8.7
> 
> 2.5/5   //0.5
> 
> 21%8  //5

算术运算符比较特殊，js不会直接将操作数作为浮点数进行计算，而是将其隐式转换为32位整数后进行运算。（确切的说，会被转换为32位大端（big-endian）的2的补码表示的整数（实话说这里真的不知道是什么意思，求科普））以按位或运算表达式为例：

> 8|1; //9

### 运算过程

首先8和1是双精度的浮点数。但也可以表示为32位整数，即32位的二进制表示。

整数8表示为32位二进制为：

> 0000 0000 0000 0000 0000 0000 0000 1000

也可能过

> (8).toString(2); //”1000”

toString的参数是转换基数

(下面是我试的以其它基数转换的，和本文无关)

> (8).toString(8); //”10”
> 
> (8).toString(16); //”8”

整数1表示为32位二进制为：

> 0000 0000 0000 0000 0000 0000 0000 0001

运行按位或

> 0000 0000 0000 0000 0000 0000 0000 1000
> 
> 0000 0000 0000 0000 0000 0000 0000 0001
> 
> -------------------------------------------------
> 
> 0000 0000 0000 0000 0000 0000 0000 1001

同样的使用标准库函数parseInt验证，同样以2作为基数，前导0不影响运算结果，不必要。

> parseInt('1001',2) //9

(下面是我试的以其它基数转换的，和本文无关)

> parseInt('1001',8) //513
> 
> parseInt('1001',16) //4097

总结算术运算的过程就是，将操作数转换为整数，然后使用整数位模式进行运算，最后将结果转换为标准的js浮点数。

**<span style="color: #ff0000;">浮点数的警示</span>**：出了名的不精确。比如

0.1+0.2; //0.30000000000000004

**原因:**尽管64位浮点数精度已经很高，但双精度浮点数也只能表示一组有限的数字，而不能表示所有的实数集。浮点运算只能产生近似的结果，四舍五入到最接近的可表示的实数。当你执行一系列的运算，随着舍入误差的积累，运算结果会越来越不精确。舍入也使算术运算定律产生一些偏差。例如结合律。对于任意实数

x,y,z总满足(x+y)+z=x+(y+z)

浮点数就不一定：

(0.1+0.2)+0.3; //0.6000000000000001

0.1+(0.2+0.3); //0.6

浮点数权衡了精度和性能，关心精度时，要小心浮点数的局限性。

**解决办法**就是把浮点运算转化为整数运算。

(10+20)+30; //60

10+(20+30); //60

然后再除少放大倍数。要注意整数范围要在-2<sup>53</sup>~2<sup>53</sup>内。

## 总结

1、js的数字都是双精度的浮点数

2、js的整数仅仅是双精度浮点数的一个子集，不是单独的一个类型

3、位运算将数字视为32位的有符号整数

4、当心浮点运算的精度问题