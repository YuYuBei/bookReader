心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：
1）将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。
2）将两个认识放在一起对照，不管它们如何简单或者复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。
3）将有关认识与那些在实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。
有关人类理解的随笔--1690 John Locke

用Lisp编程
- 为了能对某种特定形式的逻辑表达式（称为递归方程）的使用做推理
- Lisp描述的计算过程本身又可以作为Lisp的数据来表示和操作
- 可以将过程作为数据进行处理，能将过程表示为数据

1.1 程序设计的基本元素
强有力的程序设计语言
- 指挥计算机执行任务的方式
- 应该成为一种框架，能够在其中组织自己有关计算过程的思想

描述一个语言时，将注意力特别放在这一语言所提供的，能够将简单的认识组合起来形成更复杂认识的方法方面。
每一种强有力的语言都为此提供了三种机制：
- 基本表达形式，用于表示语言所关心的最简单的个体
- 组合的方法，通过它们可以从较简单的东西出发构造出复合的元素
- 抽象的方法，通过它们可以为复合对象命名，并将它们当作单元去操作

在程序设计中，需要处理两类要素：过程和数据。
- 数据是一种希望去操作的“东西”
- 过程是有关操作数据的规则的描述

任何强有力的程序设计语言
- 能表述基本的数据和基本的过程
- 需要提供对过程和数据进行组合和抽象的方法。

1.1.1 表达式
基本概念：
- 基本表达式：数
- 组合式：用一对括号括起来一些表达式，形成一个表，用于表示一个过程应用。
- 运算符：组合式中最左的元素
- 运算对象：运算符外的元素
- 求值：将运算符所刻画的过程应用于有关的实际参数（即运算对象的值）。
- 前缀表示：将运算符放在所有运算对象左边的形式

前缀表示的优点：
- 完全适用于可能带有任意个参数的过程
- 可以直接扩充，允许出现组合式嵌套的情况。允许组合式的元素本身又是组合式。


1.1.2 命名和环境
程序设计语言中的需要提供一种通过名字去使用计算对象的方式。这里的名字称为标识符，它的值就是对应的那个对象。

Scheme里，定义变量使用define的方式。

我们可以将值与符号关联，而后又能提取出这些值，这意味着解释器必须维护某种存储能力，以便保持有关的名字-值对偶的轨迹。这种存储被称为环境（全局环境）

1.1.3 组合式的求值
把与过程性思维的有关的各种问题隔离出来。
组合式的求值问题。
解释器本身的工作过程：
要求值一个组合式，做下面的事情：
- 求值该组合式的各个子表达式
- 将作为最左子表达式（运算符）的值的那个过程应用于相应的实际参数，所谓实际参数也就是其他子表达式（运算对象）的值
递归思想
计算过程的一些具有普遍性的重要问题。为了实现一个组合式的求值，必须先对组合式里的每个元素执行同样的求值过程。这个求值过程是递归的，也就是说，它在自己的工作步骤中，包含着调用这个规则本身的需要。
采用递归的思想可以简洁地描述深度嵌套的情况。
如果不用递归，相同的情况会被看成相当复杂的计算过程。需要把求值规则应用于多个不同的组合式。
```lisp
(* (+ 2 (* 4 6)) 
   (+ 3 5 7))
```
可以采用一棵树的形式，用图形表示这一组合式的求值过程，其中的每个组合式用一个带分支的结点表示，由它发出的分支对应于组合式里的运算符和各个运算对象。终端结点（即那些不再发出分支的结点）表示的是运算符或者数值。以树的观点看求值的过程，可以设想运算对象的值向上穿行，从终端结点开始，而后在越来越高的层次中组合起来。
把递归看做一种处理层次结构的极强有力的技术。
这种求值形式是更一般的计算过程，树形积累。

反复地应用第一个步骤，总可以把我们带到求值中的某一点，在这里遇到的不是组合式而是基本表达式，例如数，内部运算符或其他名字。
处理这些基础情况的方式：
- 数的值就是它们表示的数值
- 内部运算符的值就是能完成相应操作的机器指令序列
- 其他名字的值就是在环境中关联于这一名字的那个对象
关键点：环境所扮演的角色用于确定表达式中各个符号的意义。如果没有关于有关环境的任何信息，那么表达式的值是毫无意义的，表达式中的符号需要环境提供意义。
每个特殊形式都有自身的求值规则，各种不同种类的表达式组成了程序设计语言的语法形式。
Lisp的语法很简单，对各种表达式的求值规则可以描述为一个简单的通用规则和一组针对不多的特殊形式的专门规则。

1.1.4 复合过程
强有力语言包含的元素：
- 数和算术运算是基本的数据和过程
- 组合式的嵌套提供了一种组织起多个操作的方法
- 定义是一种受限的抽象手段，它为名字关联对应的值

过程定义：为复合操作提供名字，而后可以将这样的操作作为一个单元使用。

示例：定义一个求值平方的过程=>求某个值的平方就是用它自身去乘以它自身。
(define (square x)(* x x))
这里定义了一个复合过程，名字叫square，这个过程是将一个值乘以它自身。
过程定义的一般形式
(define (<name> <formal parameters>) <body>)
使用的方法
(square 21)
441
也可以通过square和定义一个新的复合过程，例如，求x^2+y^2可以写为
(define (sum-of-squares x y)(+ (square x) (square y)))
调用
(sum-of-squares 3 4)
25
复合过程的使用和基本过程完成一样。如果只是在调用时使用square，无法分辨它是定义为一个复合过程，还是在解释器内部实现的。
1.1.5 过程应用的代换模型
为了求值一个组合式（其运算符是一个复合过程的名字），解释器的工作方式将完全按照组合式的规则，采用与运算符名为基本过程的组合式一样的计算过程。即，解释器将对组合式的各个元素求值，而后将得到的那个过程（组合式里运算符的值）应用于那些实际参数（即组合式里那些运算对象的值）。
对于复合过程，过程应用的计算过程是：
- 将复合过程应用于实际参数，就是将过程体中的每个形参用相应的实参取代之后，对这一过程求值。

过程应用的代换模型，可以看作为确定过程应用的“意义”的一种模型。
- 代换的作用只是为了帮助领会过程调用中的情况，而不是解释器实际工作方式的具体描述。
- 这里的代换模型只是作为形式化考虑求值过程的起点。

模拟科学研究或者工程中的现象时，总是从最简单的不完全的模型开始。随着更细致的检查所考虑的问题，这些简单模型也会变得越来越不合适，从而必须用进一步精化的模型取代。代换模型也一样。

应用序和正则序
前面内容对有关求值的描述，解释器首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数。
这不是执行求值的唯一可能方式。另一种求值模型是先不求出运算对象的值，直到实际需要它们的值时再去做。
这种求值方式，首先用运算对象表达式去代换形式参数，直至得到一个只包含基本运算符的表达式，然后再去执行求值。
“完全展开而后归约”的求值模型称为正则序求值，与之对应的是解释器里实际使用的“先求值参数而后应用”的方式称为应用序求值。

对于那些可以通过替换去模拟，并能产生出合法值的过程应用，正则序和应用序求值将产生同样的值。
Lisp采用应用序求值，这可以避免表达式的重复求值。

1.1.6 条件表达式和谓词
分情况分析，在Lisp里有一种针对这类分情况分析的特殊形式，称为cond（表示“条件”）。
其使用形式的一般性形式如下：
(cond (<p1> <e1>)
      (<p2> <e2>)
      	   .
      	   .
      	   .
      (<pn> <en>))
这里包含了一个符号cond，在它之后跟着一些称为子句的用括号括起来的表达式对偶(<p> <e>)。在每个对偶中的第一个表达式是一个谓词，也就是，这是一个表达式，它的值将被解释为真或假。
条件表达式的求值方式：首先求值谓词<p1>,如果它的值是false，那么就去求值<p2>，如果<p2>为false就去求值<p3>。这一过程将继续下去，直到发现某个谓词的值为true为止。此时解释器就返回相应子句的序列表达式<e>的值，以这个值作为整个条件表达式的值。如果无法找到值为true的<p>，cond的值就没有定义。

术语谓词指那些返回true或false的过程，也指那种能求出true或false的值的表达式。
else是一个特殊符号，可以用在cond的最后一个子句中<p>的位置。如果前面所有的子句都被跳过，就会返回最后子句中的<e>的值。
特殊形式if,适用于分情况分析中只有两个情况的需要。
if表达式的一般形式是：
(if <predicate><consequent><alternative>)
predicate为true，对consequent求值并返回
predicate为false,对alternative求值并返回
逻辑复合运算符
(and <e1> ... <en>)
(or <e1> ... <en>)
(not <e>)

1.1.7 实例：采用牛顿法求平方根
上面介绍的过程都是常规的数学函数，它们描述的是如何根据一个或者几个参数去确定一个值。然而，在数学的函数和计算机的过程之间有一个重要差异，那就是这个过程必须是有效可行的。

函数与过程之间的矛盾，不过是在描述一件事情的特征，与描述如何去做这件整改之间的普遍性差异的一个具体反映。在数学里，人们通常关心的是说明性的描述（是什么），计算机科学里，人们则通常关心行动性的描述（怎么做）。
计算机如何算出平方根？
最常用的方法是牛顿的逐步逼进方法。
如果对x的平方根的值有一个猜测y,那么就可以通过执行一个简单操作去得到一个更好的猜测：
只需要求出y和x/y的平均值（它更接近实际的平方根值）。




1.1.8 过程作为黑箱抽象
分解中的每一个过程完成了一件可以清楚标明的工作，这使它们可以被用作定义其他过程的模块。
一个过程定义应该能隐藏起一些细节。这将使过程的使用者可能不必自己去写这些过程，而是从其他程序员那里作为一个黑箱而接受它。用户在使用一个过程时，应该不需要去弄清它是如何实现的。
局部名
内部定义和块结构


1.2 过程和它们所产生的计算
1.2.1 线性的递归和迭代
1.2.2 树形递归